\section{Web-Game [R]}
\setauthor{Rafetseder Tobias}
\subsection{Client [R]}
Für die Umsetzung des Clients wird p5.js beziehungsweise p5.play.js verwendet. 
Eine detaillierte Beschreibung zu diesen JavaScript-Bibliotheken und wie man sie in ein Projekt einbinden kann, wird in Kapitel \ref{subsection:p5js} genau beschrieben.
p5.play.js basiert auf einer Sprite Klasse. Diese Sprite-Klasse hat einige praktische vordefinierte Funktionen für zum Beispiel Collisiondetection oder Animation Support. 
Um einen Sprite zu erstellen, wird einfach die Funktion createSprite() aufgerufen.
\\
\begin{lstlisting}[language=Java,label=lst:impl:createSprite]
    function setup() {
        createCanvas(1920,1080);
        // create a sprite
        createSprite(50,50,30,30);
    }

    function draw() {
        // draw all the sprites added to the sketch so far
        // the positions will be updated automatically at every cycle
        drawSprites();
    }
\end{lstlisting}


Es ist zu beachten, dass die ersten 2 Parameter der Funktion jeweils die Position am Bildschirm in Pixel angeben, und die letzten 2 die Breite und die Höhe definieren.
Das Ergebnis:
\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/simpleSprite.PNG}
    \caption{Einfacher Sprite}
\end{figure}

Es ist noch nicht viel zu sehen, nur ein simpler Sprite, der default-mäßig ein einfaches Rechteck mit zufälliger Farbe auf einer Position erschienen ist.
Für den Player, den man in dem Web-Game sieht, wird diese Sprite-Klasse noch um ein paar Attribute erweitert:

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/playerClass.PNG}
    \caption{Player-Klasse}
\end{figure}

Zum Erstellen der Player-Klasse wird zwar ein Sprite benötigt, damit der Player am Bildschirm angezeigt wird, aber Attribute wie:
\begin{compactitem}
    \item id: Zur eindeutigen Identifizierung
    \item knockback: Wert, der erhöht wird, desto öfter man getroffen wird; desto höher der Wert, desto weiter wird man von Projektilen weggestoßen
    \item death: Anzahl, wie oft man gestorben ist
    \item kills: Anzahl an Kills, die man gemacht hat
    \item dmgDealt: Anzahl, wie oft man jemanden getroffen hat
    \item item: Array von Items, die man gerade besitzt
    \item direction: String, der die Richtung angibt, in die man gerade schaut (links oder rechts)
\end{compactitem}

Während des Spiels werden auf der Map Items gespawned. Welcher Algorithmus dahinter steckt, wird im Kapitel TODO genauer beschrieben.
Es wird zwischen 5 unterschiedlichen Items entschieden. Eine Item-Klasse hat ähnlich wie die Player-Klasse als Hauptbestandteil einen Sprite, doch auch hier werden noch weitere Attribute benötigt.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/itemClass.PNG}
    \caption{Item-Klasse}
\end{figure}

\begin{compactitem}
    \item type: Gibt den Typ des Items andere
    \item dropped: Gibt an, ob das Item irgendwo auf der Umgebung gelandet ist
    \item ammo: Anzahl, wie oft man das Item benutzen kann
\end{compactitem}

Je nachdem, welchen Typ das Item bekommen hat, wird auch die Anzahl wie oft
 man es benutzen kann, verändert. 
Wurde es zum Beispiel zum Type "bomb", kann man 5 Mal eine Bombe werfen.
\\
Bei dem Typ "mine", also einer Mine, kann man mehrere Minen gleichzeitig legen, deshalb ist das Sprite-Attribut auch ein Array.
Bei den anderen Items kann immer nur ein Sprite davon existieren.




\subsubsection{Die Items}  \label{impl:items}
Grundsätzlich gibt es 5 unterschiedliche Items in Scribble-Fight. Je nachdem, welches Item man aufgesammelt hat, kann man verschiedene Fähigkeiten aktivieren.
Für jedes Item existiert eine physics-Methode, die in der Draw-Funktion aufgerufen wird. 

\textbf{Keyboard-Access}
\\
Die Items werden alle durch Tasten auf der Tastatur ausgelöst. Durch p5.js kann man sehr leicht auf die Tastatur zugreifen. Mithilfe von ASCII Code kann man jede Taste einzeln ansteuern.
Mit der p5.js Methode <keyWentDown(Key)> wird überprüft, ob die Taste gerade gedrückt wurde.

\begin{lstlisting}[caption=Keyboard-Access,language=Java,label=lst:impl:keyboard-access]
    // E
    if (keyWentDown(69)) {
        bombAttack();
    }
    // Q
    if (keyWentDown(81)) {
        blackHoleAttack();
    }
    // R
    if (keyWentDown(82)) {
        pianoTime();
    }
    // C
    if (keyWentDown(67)) {
        placeMine();
    }
    // F
    if (keyWentDown(70)) {
        makeMeSmall();
    }
\end{lstlisting}

\textbf{Bomb}
\\
\textit{Das Bombem-Item wird mit der Taste <E> aktiviert.}
\\
Durch p5.play.js kann man mit <sprite.velocity.y> die vertikale Geschwindigkeit eines Sprites verändern. Dadurch kann eine Gravitation simuliert werden.
Außerdem kann man mit <sprite.bounce(otherSprite)> Sprites an anderen Sprites oder Gruppen von Sprites 'abspringen' lassen. Dies wird benutzt, damit die Bombe an der Umgebung abprallt
Danach wird mit <sprite.overlap(myPlayer.sprite)> überprüft, ob eine Bombe mit meinem Spieler-Sprite kollidiert.
Falls ja, wird die Bombe mit <sprite.remove()> entfernt.
Falls nein, wird noch überprüft, ob sich die Bombe außerhalb des Bildschirms befindet, und falls dies zutrifft, wird auch in dem Fall die Bombe entfernt.
\\

\begin{lstlisting}[caption=Bomb Item Physics,language=Java,label=lst:impl:bombGravity]
    // verringern der vertikalen Geschwindigkeit 
    bomb.velocity.y -= GRAVITY;
    // bombe prallt an der Umgebung ab
    bomb.bounce(environment);

    // kollidert die Bombe mit meinem Player
    if(bomb.overlapSprite(myPlayer.sprite)) {
        // my Player gets knocked back
        myPlayer.sprite.getsThrownAway();
        // bomb gets deleted
        bomb.remove();
    } else if(bombIsOutsideMonitor()) {
        // bomb gets deleted
        bomb.remove();
    }

\end{lstlisting}

\textbf{Black Hole}
\\
\textit{Das Black-Hole-Item wird mit der Taste <Q> aktiviert}.
\\
Wie bei dem Bomben-Item wird auch bei dem Black-Hole-Item Gravitation simuliert. Jedoch nur für eine kurze Zeit, bis das Item in der Luft stehen bleibt und in einem Radius alle Spieler, die sich in diesem Radius befinden, anzieht, und diese auch alle Fähigkeiten nimmt.
Um zu überprüfen, wie lange das Item schon existiert, stellt p5.play.js das <life>-Attribut zur Verfügung. Dieser Wert ist ein Countdown, der sich bei jedem Draw-Zyklus um 1 verringert, bis sich das Item dann bei dem Wert 0 selbst löscht.
Ein weiterer wichtiger Punkt ist bei dem Item, wie es Sprites anziehen kann. Dazu wurde die attraction Funktion von p5.play.js (mit leichten Veränderungen) benutzt:

\begin{lstlisting}[caption=Attraction,language=Java,label=lst:impl:attraction]
    // attraction
    if (myPlayer.sprite.overlap(b)) {
        noGravity = true;
        var angle = atan2(myPlayer.sprite.position.y - b.position.y, myPlayer.sprite.position.x - b.position.x);
        if (myPlayer.sprite.velocity.y >= -pixelWidth && myPlayer.sprite.velocity.y <= pixelWidth) {
          myPlayer.sprite.velocity.x -= cos(angle);
        }
        myPlayer.sprite.velocity.y -= sin(angle);
      }

\end{lstlisting}

Die Black-Hole-Physics Funktion sieht also (vereinfacht) so aus:
\\
\begin{lstlisting}[caption=Black Hole Item Physics,language=Java,label=lst:impl:bombGravity]
    // if the item has reached a certain life, make it static and attract players
    if (b.life <= 400) {
        attraction(b);
        b.velocity.y = 0;
        b.velocity.x = 0;
      }

      // if the item has not reached a certain life, let it bounce off the environment
      if (b.life > 400) {
        b.velocity.y -= GRAVITY;
        b.bounce(environment);
      }

      // if the item is outside of the monitor, delete it
      if (b.position.x > windowWidth || b.position.y > windowHeight || b.life == 0) {
        b.remove();
      }

\end{lstlisting}

\textbf{Piano}
\\
\textit{Das Piano-Item wird mit der Taste <R> aktiviert.}
\\
Das Piano-Item ist, wie der Namen schon vermuten lässt, ein Klavier, das am höchsten Punkt der Map erscheint und nach unten fällt.
Das bedeutet, die y-Koordinate ist 0 und die x-Koordinate ist die selbe wie die, die der Sprite des Spielers hat, der das Piano aktiviert hat.
 Bei Kontakt zu einem Spieler oder der Umgebung wird das Klavier zerstört. Zum Überprüfen auf Kollisionen wird die p5.js Methode <sprite.collide(otherSprite)> verwendet.
 Diese wird true, falls eine Kollisionen zwischen zwei Sprites oder Sprite-Gruppen stattfindet.
\\
\begin{lstlisting}[caption=Piano-Item Physics,language=Java,label=lst:impl:pianoPhy]
    // check for collisions
    if (p.collide(environment)) {
        p.remove();
      } else if (p.overlap(myPlayer.sprite)) {
        myPlayer.sprite.getsThrownAway()
        p.remove();
      }
      p.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Mine}
\\
\textit{Das Minen-Item wird mit der Taste <C> aktiviert.}
Das Minen-Item ist das einzige Item, bei dem man mehrere Instanzen auf einmal entsenden kann. 
Es taucht hinter dem eigenen Player-Sprite auf und fliegt so lange nach unten, bis es auf der Umgebung landet. Erst wenn es wo gelandet wird, wird es 'aktiv'.
Wenn eine Mine aktiviert worden ist, und ein Spieler in Berührung mit dem Item kommt, wird dieser in die Luft gestoßen und die Mine wird gelöscht.
\\
\begin{lstlisting}[caption=Mine-Item Physics,language=Java,label=lst:impl:minePhy]
    // check if mine has landed somewhere (if true: activate mine)
    if (m.collide(environment) && m.touching.bottom) {
        m.set = true;
    }
    if (m.overlap(myPlayer.sprite) && m.set) {
        myPlayer.sprite.getsThrownAway();
        m.remove();
    }
    m.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Size-Reduction}
\\
\textit{Das Size-Reduction-Item wird mit der Taste <F> aktiviert.}
\\
Dieses Item ist das einzige, das keinen eigenen Sprite hat. Das einzige was diese Item macht, ist, den Spieler-Sprite zu verkleinern. Dadurch wird dieser schwieriger zu treffen.
Der Code, der dies umsetzt, sieht vereinfacht so aus:
\\
\begin{lstlisting}[caption=Size-Reduction,language=Java,label=lst:impl:sizeReduc]
// gets called on key press F
function makeMeSmall() {
  if (doIHaveTheItem()) {
    imSmall = true;
    smallTimer = 10;
  }
}

// gets called in draw function
function smallChecker() {
  if (imSmall) {
    // scale the sprite down at the start of countdown
    if (smallTimer == 10) {
      myPlayer.sprite.scale = 0.6;
    }
    // every second (60 frames), the countdown gets reducced
    if (frameCount % 60 == 0 && smallTimer > 0) {
      smallTimer--;
    }
    // if the countdown is over, rescale the sprite back to the original form
    if (smallTimer == 0) {
      myPlayer.sprite.scale = 1;
      smallTimer = 10;
      imSmall = false;
    }
  }

}
\end{lstlisting}

\textbf{Die Default-Attacke}
\\
\textit{Die Default-Attacke wird mit <Left-Click> aktiviert.}
\\
p5.js bietet sehr leicht die Möglichkeit, auf User-Input zu überprüfen. Das einzige, was nötig ist um zu erkennen, ob der User gerade die linke Maustaste geklickt hat, ist die Funktion <mouseClicked()>.
Mit diesen Funktionalitäten wird nun zu dem Punkt, auf dem man gerade die Maus hält und die Default-Attacke aktiviert, ein Projektil abgeschossen. Um die Information zu erhalten, auf welcher X- und Y-Position sich die Maus befindet,
 werden die von p5.js vordefinierten Eigenschaft <camera.mouseX> und <camera.mouseY> verwendet.
\\
\begin{lstlisting}[caption=Default-Attacke,language=Java,label=lst:impl:defaultAttack]
    function mouseClicked() {
    // Maus-Position
    let x = camera.mouseX,
        y = camera.mouseY;
    // Sprite wird bei meiner Player-Sprite-Positon erstellt
    projectile = createSprite(myPlayer.sprite.position.x, myPlayer.sprite.position.y, pixelWidth, pixelWidth);
      
    // Geschwindigkeit wird auf die Position der Maus ausgerichtet
    projectile.velocity.x = (x - myPlayer.sprite.position.x);
    projectile.velocity.y = (y - myPlayer.sprite.position.y);
}

\end{lstlisting}

\subsubsection{Movements}
Es gibt 3 fundamentale Bewegungsmöglichkeiten in Scribble-Fight. Springen, links/rechts laufen und 'klettern'. Diese Bewegungen werden im Folgenden genauer erläutert.

\textbf{Springen}
\\
In dem Web-Game springt man mittels Leertaste. Genau wie bei den Items, wird mittels den p5.js Methoden der User-Input ermittelt.
Bei dem Springbewegung wird einfach die vertikale Geschwindigkeit des Player-Sprites so verändert, dass dieser etwas nach oben springt.
\\
\begin{lstlisting}[caption=Jumping,language=Java,label=lst:impl:jumping]
    // check if user pressed spacebar
    if (keyWentDown(32)) {
        jump()
    }

    function jump() {
    // user is only allowed to jump 2 times (it resets when touching the ground)
    if (!(JUMP_COUNT >= MAX_JUMP)) {
        // make the user fly up a bit (JUMP is a global variable)
        myPlayer.sprite.velocity.y = -JUMP;
        JUMP_COUNT++;
    }
}
\end{lstlisting}

\textbf{Links/Rechts Laufen}
\\
Das Prinzip des Links oder Rechts Bewegens ist sehr simpel. Es wird einfach die horizontale Geschwindigkeit des Player-Sprites auf eine konstante Variable gesetzt.
Wenn man sich nach rechts bewegt, ist diese Konstante positiv, bei einer Linksbewegung negativ. Im Gegensatz zur Springbewegung wird diesmal aber die Methode <keyIsDown(key)> verwendet, und nicht <keyWentDown(key)>.
Der Grund dafür ist, dass die Bewegung so lange anhalten soll, wie der User die Taste drückt, und nicht nur einmal pro Tastendruck.

\begin{lstlisting}[caption=Links/Rechts-Movement,language=Java,label=lst:impl:moving]
    //A
    if (keyIsDown(65)) {
        moveLeft()
    }
    //D
    if (keyIsDown(68)) {
        moveRight()
    }

    // SPEED is a global variable
    function moveLeft() {
    myPlayer.sprite.velocity.x = -SPEED;
    }

    function moveRight() {
    myPlayer.sprite.velocity.x = SPEED;
    }
\end{lstlisting}

\textbf{Bewegung auf der Spielumgebung}
\\
Die Bewegung auf der Spielumgebung wird durch die Methode <collisions()> bestimmt. Diese wird in der draw-Methode aufgerufen und wird somit 60 mal die Sekunde ausgeführt.
Berührt der Sprite des Players nichts, fällt er er mit konstanter Beschleunigung nach unten.
Findet jedoch eine Kollision mit der Spielumgebung statt, dann wird überprüft, welche Art von Berührung gerade stattfindet:

\begin{compactitem}
    \item Falls Berührung seitlich: Player-Sprite bekommt eine Klettergeschwindigkeit und behält diese so lange, wie die Berührung stattfindet
    \item Falls Berührung unten: Die vertikale Geschwindigkeit des Player-Sprites wird auf 0 gesetzt und der Sprung-Counter zurückgesetzt
    \item Falls Berührung oben: Mit einer Berührung die zwischen Spielumgebung und Sprite stattfindet, kann man nicht klettern noch wird der Sprung-Counter zurückgesetzt
\end{compactitem}

\begin{lstlisting}[caption=Bewegung auf der Spielumgebung,language=Java,label=lst:impl:collisions]
    // check for collisions
    if (myPlayer.sprite.collide(environment)) {
      // if the collision is on the side, the sprite will start "climbing" with a certain speed
      if (myPlayer.sprite.touching.left || myPlayer.sprite.touching.right) {
        myPlayer.sprite.velocity.y = CLIMBINGSPEED;
      }
      // standing on the environment
      if(myPlayer.sprite.touching.bottom) {
        myPlayer.sprite.velocity.y = 0; 
      }
      // jump count gets only reset when the collision is not on the top of the player-sprite
      if (!myPlayer.sprite.touching.top) {
        JUMP_COUNT = 0;
      }
    }
\end{lstlisting}

\textbf{Knockback-Bewegung} \\
Wenn man von einem Projektil getroffen wurde, wird der eigene Player-Sprite für kurze Zeit bewegungsunfähig und prallt von der Spielumgebung ab.
Wie lang dieses Knockback-Movement andauert, kommt auf die Art des Projektils und auf den Wert des Knockbacks des Players an.
Soll der Player-Sprite also nun diese Bewegung ausführen, wird das mit einer Funktion namens <sendHimFlying()> bewerkstelligt.
Bevor diese aufgerufen wird, muss noch wie der Countdown, wie lange der Sprite nun in dieser Bewegung bleiben soll, festgelegt werden. Bei jedem draw-Zyklus wird dieser Countdown um den Wert eins verringert.
Hinzu kommt noch, dass wenn man also getroffen wurde, man kurz etwas verlangsamt wird. Es soll so wirken, als wäre man gerade etwas betäubt worden.
\begin{lstlisting}[caption=Knockback-Bewegung,language=Java,label=lst:impl:knockbackMov]
// before function gets called, make sure to set flying to true and set a flying-duration
function sendHimFlying() {
  if (flying) {
    timeFlying--;
    //slowdown 
    if (timeFlying <= flyingDuration / 2 && timeFlying > 0) {
      if (myPlayer.sprite.velocity.x > 0) { myPlayer.sprite.velocity.x -= 0.3; }
      if (myPlayer.sprite.velocity.x < 0) { myPlayer.sprite.velocity.x += 0.3; }
      if (myPlayer.sprite.velocity.y > 0) { myPlayer.sprite.velocity.y -= 0.3; }
      if (myPlayer.sprite.velocity.y < 0) { myPlayer.sprite.velocity.y += 0.3; }
    }
    // flying-duration is over
    if (timeFlying == 0) {
      flying = false;
    }
  }
}
\end{lstlisting}


\textbf{Richtungswechsel des Sprites}
\\
Ein weiterer wichtiger Aspekt bei der Bewegung des Player-Sprites ist, dass sich auch die Orientierung des Bildes ändern muss, wenn dieser die Richtung wechselt.
Auch für diese Problemstellung stellt p5.play.js eine Lösung zu Verfügung. Mit der Methode <mirrorX()> wird der Sprite entlang seiner vertikalen Achse gespiegelt.
Jedes mal, wenn der User nun also die Richtung seines Player-Sprites wechselt, wird auch der Sprites passend seiner Bewegung gespiegelt.

\begin{lstlisting}[caption=Sprite Richtungswechsel,language=Java,label=lst:impl:mirrorSprite]
    function mirrorSprite() {
        // A
        if (keyWentDown(65)) {
            mirrorSpriteLeft()
        }
        // D
        if (keyWentDown(68)) {
            mirrorSpriteRight()
        }
    }
    
    function mirrorSpriteLeft() {
        // if the mirrorX attribute is 1, then the sprite is looking to the right
        if (myPlayer.sprite.mirrorX() === 1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "left";
        }
    }
    
    function mirrorSpriteRight() {
        // if the mirrorX attribute is 1, then the sprite is looking to the left
        if (myPlayer.sprite.mirrorX() === -1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "right";
        }
    }
\end{lstlisting}

\subsubsection{Wie gewinne ich?}
Um in Scribble-Fight zu gewinnen, muss man seinen Gegner/seine Gegner drei mal erfolgreich von der Spielumgebung schießen, so, dass der Sprite des Gegners ins Nichts fällt.
Dies ist durch die Attacken, die in Kapitel \ref{impl:items} genau beschreiben werden, möglich. 
Um zu überprüfen, ob der Sprite nun hinuntergefallen und somit 'gestorben' ist, wird in der draw-Methode die Funktion <deathCheck()> aufgerufen.
Diese hat einige Aufgaben:
\begin{compactitem}
    \item Überprüfen ob sich der Player-Sprite außerhalb des Bildschirms befindet
    \item Falls ja, überprüfen ob der Player noch mindestens ein Leben hat
    \item Falls der Player keine Leben mehr hat, wird sein Sprite zerstört
    \item Hat der Player noch weitere Leben, dann wird er nach drei Sekunden an einem zufälligen Punkt, an dem er nicht direkt wieder aus dem Bildschirm fällt, gespawned
    \item Wird der Player respawned, werden ihm alle seine Items, die er eventuell noch hatte, wieder genommen
    \item Wird der Player respawned, wird sein Knockback wieder zurückgesetzt
\end{compactitem}

Vereinfacht sieht die Methode also so aus:

\begin{lstlisting}[caption=Überprüfung nach Toden,language=Java,label=lst:impl:deathCheck]
function deathCheck() {
    // check if sprite has fallen outside of the monitor
    if (myPlayer.sprite.position.y - player_height > windowHeight && !respawnTime) {
        youDied();
    }
}

function youDied() {
    myPlayer.removeItem();
    myPlayer.death++;
    myPlayer.knockback = 0;
    respawnTime = true;

    // after 3 seconds the player gets respawned on a location, if he still has at least one live left
    setTimeout(() => {
        if (myPlayer.death < 3) {
            myPlayer.sprite.position.x = xCoordinates[Math.floor(Math.random() * xCoordinates.length)];
            myPlayer.sprite.position.y = 0;
            respawnTime = false;
        }
    }, 3000);
}
\end{lstlisting}

Außerdem zählt es auch als Tod, wenn der Knockback des eigenen Players über 100 ansteigt. Dies wird mit der <fatalHit()>-Methode überprüft.
Diese Methode wird immer dann aufgerufen, wenn der eigene Player von irgendeinem Projekil getroffen wurde.
\begin{lstlisting}[caption=Fatal Hit,language=Java,label=lst:impl:falatHit]
    function fatalHit() {
        if (myPlayer.knockback >= 100) {
            youDied();
        }
    } 
\end{lstlisting}

\subsubsection{Erstellung der Spielumgebung} \label{impl:Spielumgebung}
Um sich auch auf dem Bild, das der User gezeichnet hat, bewegen zu können, muss einiges gemacht werden. Mittels Objekterkennung kann das Bild abfotografiert, 
und daraus ein Array mit Bildaten erstellt werden, aus dem man dann wiederum die Spielumgebung kreiert. Wie genau dieser Array zustande kommt, wird in Kapitel TODO beschrieben.
\\
\begin{lstlisting}[caption=Vereinfachte Darstellung eines Bilddaten-Arrays,language=Java,label=lst:impl:bilddaten]
    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [255, 255, 255, 0], [252, 252, 252, 0], [251, 251, 251, 0],
    [248, 248, 248, 0], [249, 249, 249, 0], [247, 247, 247, 0],
    [255, 255, 255, 0], [240, 240, 240, 0], [250, 250, 250, 0],
    [174, 174, 174, 0], [255, 255, 255, 0], [173, 173, 173, 0],
    [226, 226, 226, 0], [255, 255, 255, 0], [253, 253, 253, 0],
    [163, 163, 163, 0], [254, 254, 254, 0], [255, 255, 255, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [[0, 0, 0, 0],
\end{lstlisting}

Desto genauer dieser Array ist, desto genauer werden auch die Hitboxen der Spielumgebung.
Hat ein Eintrag des Arrays an Stelle vier mehr als 0 als Wert, wird dort ein Pixel erstellt. Das liegt daran, dass an der vierten Stelle eines solchen Eintrags die Opacity der Bildstelle angegeben wird. Das bedeutet, jemand hat dort etwas gezeichnet.
Natürlich muss der Sprite-Pixel noch einen richtigen X- und Y-Wert bekommen. Diese Koordinate muss auch mit dem Punkt des Bildes übereinstimmen, an den der Sprite als Hitbox agieren soll.
Aus Perfomance-Gründen (Es wird durchgehend auf Kollidierung zwischen Player und Spielumgebung geprüft) werden die Sprite-Pixel entlang der X-Achse noch zusammengefasst.
Wurden nun alle Sprite-Pixel ausfindig gemacht, mit richtigen Koordinaten versehen und entlang der horizontalen Achse zusammengefasst, werden alle einer p5-Group-Variable hinzugefügt.
Das macht das Überprüfen auf Kollision sehr leicht. \\
Die nächsten drei Bilder sollen den Ablauf bildlich darstellen.

Zuerst hat man das originale, vom User gezeichnete Bild.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing.PNG}
    \caption{Originale Zeichnung}
\end{figure}

Daraus erhält man nun druch Objekterkennung einen Array aus den Bilddaten. Wenn man nun aber einfach mit diesem Array 
die Pixel für die Spielumgebung erstellt, sind diese noch viel zu klein und an der falschen Position.
\\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing2.PNG}
    \caption{Bilddaten-Array bildich dargestellt}
\end{figure}

Um die richtigen Koordinaten für die Sprite-Pixel zu bestimmen, werden noch einige andere Faktoren miteinbezogen und daraus dann die richtige Position der Pixel am Bildschirm ermittelt.
Außerdem werden sie noch entlang der X-Achse kombiniert.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{pics/simpleDrawing3.PNG}
    \caption{Spielumgebung}
\end{figure}

Natürlich werden dann diese Sprites versteckt. Es soll ja so wirken, also würde sich der User auf dem, was er gerade gezeichnet hat, bewegen können.
Im Folgenden wird der Algorithmus zum Aufbereiten der Spielumgebung vereinfacht dargestellt. 
\begin{lstlisting}[caption=Erstellen der Spielumgebung,language=Java,label=lst:impl:createEnv]
    environment = new Group();
    // looping through image data array
    for (let i = 0; i < pixel_clumps.length; i++) {
      sprite_pixels[i] = [];
      for (let j = 0; j < pixel_clumps[0].length; j++) {
        if the value is greater than 0, then something has been drawn there
        if (pixel_clumps[i][j][3] > 0) {
          //if the last value in the array is not undefined, we can merge the sprite-pixels
          if (sprite_pixels[i][j - 1] !== undefined) {
            same_x_counter++;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth + faktorY, pixelWidth * same_x_counter, pixelWidth);
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
            // remove the last value, because it has been replaced by a new sprite, with more width
            sprite_pixels[i][j - 1].remove();
            sprite_pixels[i][j - 1] = undefined;
          } else {
            same_x_counter = 1;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth + faktorY, pixelWidth, pixelWidth); 
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
          }
        }
      }
    }
\end{lstlisting}

\subsubsection{Item-Spawns}
Alle 10 Sekunden wird 1 Item gespawned.
Es wird an oberster Stelle des Bildschirms kreiert (y-Koordiante = 0); die x-Position dieses Items wird dann zufällig ausgewählt. 
Wichtig dabei ist jedoch, dass das Items auf keiner Position spawnen darf, bei der es einfach oben auftaucht und dann aus dem Bildschirm fällt.
Wie genau man zu diesen x-Koordiaten kommt, wird in Kapitel \ref{impl:xCoordinates} genau beschrieben. 
Damit man Items voneinder unterscheiden kann, wird jede Art von Item farblich gekennzeichnet:

\begin{compactitem}
    \item Rot: Bomb
    \item Blau: Black-Hole
    \item Gelb: Piano
    \item Orange: Mine
    \item Grün: Size-Reduction
\end{compactitem}

Den Input, wann ein Item genau erstellt wird, (muss bei jedem User der gerade spielt gleich sein!) liefert der Server. Genauere Details wie der Server von Scribble-Fight funktioniert, findet man in Kapitel TODO
\\

\begin{lstlisting}[caption=Erstellen eines Items,language=Java,label=lst:impl:createItem]
funciton createItem(data) {
    // number between 1-5 from the server to create a random item
    let num = data.num;
    // random x-Coordinate from the server
    let x = data.x
    // this equation gets you the highest point of the map
    let y = (windowHeight - ImageHeight) / 2;
    // if x = -1, something on the server-side went wrong
    if (x != -1) {
        // itemSize is a global variable
        switch (num) {
            case 1:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "bomb";
                break;
            case 2:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "black_hole";
                break;
            case 3:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "piano";
                break;
            case 4:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "mine";
                break;
            case 5:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "small";
                break;
        }
        i.dropped = false;
        items.push(i);
    }
\end{lstlisting}

Nachdem nun das Item erstellt wurde, braucht dieses natürlich auch so wie zum Beispiel die Projektile oder der Player eine eigene Physik-Methode. Diese wird, so wie die anderen Physik-Methoden auch, in der Draw-Methode aufgerufen.
Die Methode funktioniert so, dass das Item so lange fällt, bis es irgenwo auf der Spielumgebung landet. Jeder Player kann das Item berühren und somit eine neue Fähigkeit bekommen.

\begin{lstlisting}[caption=Item-Physik,language=Java,label=lst:impl:itemPhy]
    function itemPickUp() {
        if (items.length > 0) {
            items.forEach(item => {
                // if the item collides with the environment, the dropped-attribute becomes true
                if(item.collide(environment)) {
                    item.dropped = true;
                }
                // if the item has not landed anywhere, let it fall 
                if(!item.dropped) {
                    item.velocity.y -= GRAVITY;
                }
    
                // if I collide with the item, I get a new ability depending on the type of the item and the item gets deleted
                if (item.overlap(myPlayer.sprite)) {
                    myPlayer.item[item.type] = new Item(item.type);
                    deleteItem(item);
                }
        }
    }
    \end{lstlisting}

\textbf{Bestimmung von gültigen X-Koordinaten} \label{impl:xCoordinates}
\\
Mit gültiger X-Koordinaten sind jene X-Koordinaten gemeint, bei denen ein Sprite erstellt werden kann, und man sich sicher sein kann, dass der gespawnte Sprite auf der Spielumgebung landen wird und nicht einfach aus dem Bildschirm fliegt.
Um den Algorithmus verstehen zu können, muss man wissen, wie die Spielumgebung erstellt wird und was ein Pixel-Width ist. Dies wird in Kapitel \ref{impl:Spielumgebung} beschrieben.
Bei dem Algorithmus wird zuerst überprüft, auf welchen Stellen Sprite-Pixel vorhanden sind. Von diesen kann schon der Mittelpunkt als gültige X-Koordiaten genommen werden, solange dieser Pixel eine gewisse Breite aufweist. 
Doch damit bei einem sehr breiten Pixel nicht nur eine einzige X-Koordinate ausgewählt wird, wird schrittweise überprüft, ob noch Stellen vor oder hinter dem Mittelpunkt des Sprites in Frage kommen.
Dazu wird dieser Sprite-Pixel nach vorne und nach hinten abgetastet, ob noch genügend Platz da ist, ein Item dort landen zu lassen. 
Es können höchstens halb so viele X-Koordiaten pro Sprite-Pixel ausgewählt werden, wie der Pixel (in Pixel-Width gemessen) breit ist. 
Die Funktion wird im Setup von Scribble-Fight aufgerufen. 

\begin{lstlisting}[caption=Bestimmung gültiger X-Koordinaten,language=Java,label=lst:impl:xCoords]
    function getXCoordinates() {
        let sprite;
        // looping through the sprite_pixel array
        for (let i = 0; i < sprite_pixels.length; i++) {
            for (let j = 0; j < sprite_pixels[i].length; j++) {
                sprite = sprite_pixels[i][j];
                // if the sprite variable is not undefined, it means a sprite exists there
                // the sprite hast to be a width of at least 4 times the normal pixel width
                if (sprite !== undefined && sprite.width >= pixelWidth * 4) {
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the right of the center)
                    for (let index = 0; index < sprite.width / 2; index += pixelWidth * 2) {
                        if (sprite.position.x + index < sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index;
                            xCoordinates.push(x);
                        }
                    }
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the left of the center)
                    for (let index = sprite.width; index > sprite.width / 2; index -= pixelWidth * 2) {
                        if (sprite.position.x + index > sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index - sprite.width;
                            xCoordinates.push(x);
                        }
                    }
                    // doing this eliminates duplicates
                    xCoordinates = Array.from(new Set(xCoordinates));
                }
            }
            return xCoordinates;
        }
    }
\end{lstlisting}






\subsection{Server [R]}
\subsubsection{Node.js [R]}
\subsubsection{SocketIO [R]}
\subsection{Gamephysics [R]}
\subsection{Hitregistration [R]}
\subsection{Collisiondetection [R]}
\subsection{Regeln und Spielablauf [R]}
\section{Deployment [R]}
\setauthor{Rafetseder Tobias}
\subsection{Docker [R]}
\subsection{Leo-Cloud [R]}

% Ben dein teil kommt hier herein

\input{./sections/Jonas/mapandai.tex}


% Siehe tolle Daten in Tab. \ref{tab:impl:data}.

% \begin{table}
%     \centering
%     \begin{tabular}{|lcc|}
%         \hline
%                   & \textbf{Regular Customers} & \textbf{Random Customers} \\ \hline
%         Age       & 20-40                      & \textgreater{}60          \\ \hline
%         Education & university                 & high school               \\ \hline
%     \end{tabular}
%     \caption{Ein paar tabellarische Daten}
%     \label{tab:impl:data}
% \end{table}

% \begin{figure}
%     \centering
%     \includegraphics[scale=0.5]{pics/knuthi.jpg}
%     \caption{Don Knuth -- CS Allfather}
%     \label{fig:impl:knuth}
% \end{figure}

% Siehe und staune in Abb. \ref{fig:impl:knuth}.
% \lipsum[6-9]
% Dann betrachte den Code in Listing \ref{lst:impl:foo}.

% \begin{lstlisting}[language=Python,caption=Some code,label=lst:impl:foo]
% # Program to find the sum of all numbers stored in a list (the not-Pythonic-way)

% # List of numbers
% numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]

% # variable to store the sum
% sum = 0

% # iterate over the list
% for val in numbers:
%     sum = sum+val

% print("The sum is", sum)
% \end{lstlisting}