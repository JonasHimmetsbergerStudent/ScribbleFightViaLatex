\section{Web-Game [R]}
\setauthor{Rafetseder Tobias}
\subsection{Frontend [R]}
Für die Umsetzung des Frontends wird p5.js beziehungsweise p5.play.js verwendet. 
Eine detaillierte Beschreibung zu diesen JavaScript-Bibliotheken und wie man sie in ein Projekt einbinden kann, wird in Kapitel \ref{subsection:p5js} genau beschrieben.
p5.play.js basiert auf einer Sprite Klasse. Diese Sprite-Klasse hat einige praktische vordefinierte Funktionen für zum Beispiel Collisiondetection oder Animation Support. 
Um einen Sprite zu erstellen, wird einfach die Funktion createSprite() aufgerufen.
\\
\begin{lstlisting}[language=Java,label=lst:impl:createSprite]
    function setup() {
        createCanvas(1920,1080);
        // create a sprite
        createSprite(50,50,30,30);
    }

    function draw() {
        // draw all the sprites added to the sketch so far
        // the positions will be updated automatically at every cycle
        drawSprites();
    }
\end{lstlisting}


Es ist zu beachten, dass die ersten 2 Parameter der Funktion jeweils die Position am Bildschirm in Pixel angeben, und die letzten 2 die Breite und die Höhe definieren.
Das Ergebnis:
\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/simpleSprite.PNG}
    \caption{Einfacher Sprite}
\end{figure}

Es ist noch nicht viel zu sehen, nur ein simpler Sprite, der default-mäßig ein einfaches Rechteck mit zufälliger Farbe auf einer Position erschienen ist.
Für den Player, den man in dem Web-Game sieht, wird diese Sprite-Klasse noch um ein paar Attribute erweitert:

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/playerClass.PNG}
    \caption{Player-Klasse}
\end{figure}

Zum Erstellen der Player-Klasse wird zwar ein Sprite benötigt, damit der Player am Bildschirm angezeigt wird, aber Attribute wie:
\begin{compactitem}
    \item id: Zur eindeutigen Identifizierung
    \item knockback: Wert, der erhöht wird, desto öfter man getroffen wird; desto höher der Wert, desto weiter wird man von Projektilen weggestoßen
    \item death: Anzahl, wie oft man gestorben ist
    \item kills: Anzahl an Kills, die man gemacht hat
    \item dmgDealt: Anzahl, wie oft man jemanden getroffen hat
    \item item: Array von Items, die man gerade besitzt
    \item direction: String, der die Richtung angibt, in die man gerade schaut (links oder rechts)
\end{compactitem}

Während des Spiels werden auf der Map Items gespawned. Welcher Algorithmus dahinter steckt, wird im Kapitel TODO genauer beschrieben.
Es wird zwischen 5 unterschiedlichen Items entschieden. Eine Item-Klasse hat ähnlich wie die Player-Klasse als Hauptbestandteil einen Sprite, doch auch hier werden noch weitere Attribute benötigt.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/itemClass.PNG}
    \caption{Item-Klasse}
\end{figure}

\begin{compactitem}
    \item type: Gibt den Typ des Items andere
    \item dropped: Gibt an, ob das Item irgendwo auf der Umgebung gelandet ist
    \item ammo: Anzahl, wie oft man das Item benutzen kann
\end{compactitem}

Je nachdem, welchen Typ das Item bekommen hat, wird auch die Anzahl wie oft
 man es benutzen kann, verändert. 
Wurde es zum Beispiel zum Type "bomb", kann man 5 Mal eine Bombe werfen.
\\
Bei dem Typ "mine", also einer Mine, kann man mehrere Minen gleichzeitig legen, deshalb ist das Sprite-Attribut auch ein Array.
Bei den anderen Items kann immer nur ein Sprite davon existieren.




\subsubsection{Die Items}  \label{impl:items}
Grundsätzlich gibt es 5 unterschiedliche Items in Scribble-Fight. Je nachdem, welches Item man aufgesammelt hat, kann man verschiedene Fähigkeiten aktivieren.
Für jedes Item existiert eine physics-Methode, die in der Draw-Funktion aufgerufen wird. 

\textbf{Keyboard-Access}
\\
Die Items werden alle durch Tasten auf der Tastatur ausgelöst. Durch p5.js kann man sehr leicht auf die Tastatur zugreifen. Mithilfe von ASCII Code kann man jede Taste einzeln ansteuern.
Mit der p5.js Methode <keyWentDown(Key)> wird überprüft, ob die Taste gerade gedrückt wurde.

\begin{lstlisting}[caption=Keyboard-Access,language=Java,label=lst:impl:keyboard-access]
    // E
    if (keyWentDown(69)) {
        bombAttack();
    }
    // Q
    if (keyWentDown(81)) {
        blackHoleAttack();
    }
    // R
    if (keyWentDown(82)) {
        pianoTime();
    }
    // C
    if (keyWentDown(67)) {
        placeMine();
    }
    // F
    if (keyWentDown(70)) {
        makeMeSmall();
    }
\end{lstlisting}

\textbf{Bomb}
\\
\textit{Das Bombem-Item wird mit der Taste <E> aktiviert.}
\\
Durch p5.play.js kann man mit <sprite.velocity.y> die vertikale Geschwindigkeit eines Sprites verändern. Dadurch kann eine Gravitation simuliert werden.
Außerdem kann man mit <sprite.bounce(otherSprite)> Sprites an anderen Sprites oder Gruppen von Sprites 'abspringen' lassen. Dies wird benutzt, damit die Bombe an der Umgebung abprallt
Danach wird mit <sprite.overlap(myPlayer.sprite)> überprüft, ob eine Bombe mit meinem Spieler-Sprite kollidiert.
Falls ja, wird die Bombe mit <sprite.remove()> entfernt.
Falls nein, wird noch überprüft, ob sich die Bombe außerhalb des Bildschirms befindet, und falls dies zutrifft, wird auch in dem Fall die Bombe entfernt.
\\

\begin{lstlisting}[caption=Bomb Item Physics,language=Java,label=lst:impl:bombGravity]
    // verringern der vertikalen Geschwindigkeit 
    bomb.velocity.y -= GRAVITY;
    // bombe prallt an der Umgebung ab
    bomb.bounce(environment);

    // kollidert die Bombe mit meinem Player
    if(bomb.overlapSprite(myPlayer.sprite)) {
        // my Player gets knocked back
        myPlayer.sprite.getsThrownAway();
        // bomb gets deleted
        bomb.remove();
    } else if(bombIsOutsideMonitor()) {
        // bomb gets deleted
        bomb.remove();
    }

\end{lstlisting}

\textbf{Black Hole}
\\
\textit{Das Black-Hole-Item wird mit der Taste <Q> aktiviert}.
\\
Wie bei dem Bomben-Item wird auch bei dem Black-Hole-Item Gravitation simuliert. Jedoch nur für eine kurze Zeit, bis das Item in der Luft stehen bleibt und in einem Radius alle Spieler, die sich in diesem Radius befinden, anzieht, und diese auch alle Fähigkeiten nimmt.
Um zu überprüfen, wie lange das Item schon existiert, stellt p5.play.js das <life>-Attribut zur Verfügung. Dieser Wert ist ein Countdown, der sich bei jedem Draw-Zyklus um 1 verringert, bis sich das Item dann bei dem Wert 0 selbst löscht.
Ein weiterer wichtiger Punkt ist bei dem Item, wie es Sprites anziehen kann. Dazu wurde die attraction Funktion von p5.play.js (mit leichten Veränderungen) benutzt:

\begin{lstlisting}[caption=Attraction,language=Java,label=lst:impl:attraction]
    // attraction
    if (myPlayer.sprite.overlap(b)) {
        noGravity = true;
        var angle = atan2(myPlayer.sprite.position.y - b.position.y, myPlayer.sprite.position.x - b.position.x);
        if (myPlayer.sprite.velocity.y >= -pixelWidth && myPlayer.sprite.velocity.y <= pixelWidth) {
          myPlayer.sprite.velocity.x -= cos(angle);
        }
        myPlayer.sprite.velocity.y -= sin(angle);
      }

\end{lstlisting}

Die Black-Hole-Physics Funktion sieht also (vereinfacht) so aus:
\\
\begin{lstlisting}[caption=Black Hole Item Physics,language=Java,label=lst:impl:bombGravity]
    // if the item has reached a certain life, make it static and attract players
    if (b.life <= 400) {
        attraction(b);
        b.velocity.y = 0;
        b.velocity.x = 0;
      }

      // if the item has not reached a certain life, let it bounce off the environment
      if (b.life > 400) {
        b.velocity.y -= GRAVITY;
        b.bounce(environment);
      }

      // if the item is outside of the monitor, delete it
      if (b.position.x > windowWidth || b.position.y > windowHeight || b.life == 0) {
        b.remove();
      }

\end{lstlisting}

\textbf{Piano}
\\
\textit{Das Piano-Item wird mit der Taste <R> aktiviert.}
\\
Das Piano-Item ist, wie der Namen schon vermuten lässt, ein Klavier, das am höchsten Punkt der Map erscheint und nach unten fällt.
Das bedeutet, die y-Koordinate ist 0 und die x-Koordinate ist die selbe wie die, die der Sprite des Spielers hat, der das Piano aktiviert hat.
 Bei Kontakt zu einem Spieler oder der Umgebung wird das Klavier zerstört. Zum Überprüfen auf Kollisionen wird die p5.js Methode <sprite.collide(otherSprite)> verwendet.
 Diese wird true, falls eine Kollisionen zwischen zwei Sprites oder Sprite-Gruppen stattfindet.
\\
\begin{lstlisting}[caption=Piano-Item Physics,language=Java,label=lst:impl:pianoPhy]
    // check for collisions
    if (p.collide(environment)) {
        p.remove();
      } else if (p.overlap(myPlayer.sprite)) {
        myPlayer.sprite.getsThrownAway()
        p.remove();
      }
      p.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Mine}
\\
\textit{Das Minen-Item wird mit der Taste <C> aktiviert.}
Das Minen-Item ist das einzige Item, bei dem man mehrere Instanzen auf einmal entsenden kann. 
Es taucht hinter dem eigenen Player-Sprite auf und fliegt so lange nach unten, bis es auf der Umgebung landet. Erst wenn es wo gelandet wird, wird es 'aktiv'.
Wenn eine Mine aktiviert worden ist, und ein Spieler in Berührung mit dem Item kommt, wird dieser in die Luft gestoßen und die Mine wird gelöscht.
\\
\begin{lstlisting}[caption=Mine-Item Physics,language=Java,label=lst:impl:minePhy]
    // check if mine has landed somewhere (if true: activate mine)
    if (m.collide(environment) && m.touching.bottom) {
        m.set = true;
    }
    if (m.overlap(myPlayer.sprite) && m.set) {
        myPlayer.sprite.getsThrownAway();
        m.remove();
    }
    m.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Size-Reduction}
\\
\textit{Das Size-Reduction-Item wird mit der Taste <F> aktiviert.}
\\
Dieses Item ist das einzige, das keinen eigenen Sprite hat. Das einzige was diese Item macht, ist, den Spieler-Sprite zu verkleinern. Dadurch wird dieser schwieriger zu treffen.
Der Code, der dies umsetzt, sieht vereinfacht so aus:
\\
\begin{lstlisting}[caption=Size-Reduction,language=Java,label=lst:impl:sizeReduc]
// gets called on key press F
function makeMeSmall() {
  if (doIHaveTheItem()) {
    imSmall = true;
    smallTimer = 10;
  }
}

// gets called in draw function
function smallChecker() {
  if (imSmall) {
    // scale the sprite down at the start of countdown
    if (smallTimer == 10) {
      myPlayer.sprite.scale = 0.6;
    }
    // every second (60 frames), the countdown gets reducced
    if (frameCount % 60 == 0 && smallTimer > 0) {
      smallTimer--;
    }
    // if the countdown is over, rescale the sprite back to the original form
    if (smallTimer == 0) {
      myPlayer.sprite.scale = 1;
      smallTimer = 10;
      imSmall = false;
    }
  }

}
\end{lstlisting}

\textbf{Die Default-Attacke}
\\
\textit{Die Default-Attacke wird mit <Left-Click> aktiviert.}
\\
p5.js bietet sehr leicht die Möglichkeit, auf User-Input zu überprüfen. Das einzige, was nötig ist um zu erkennen, ob der User gerade die linke Maustaste geklickt hat, ist die Funktion <mouseClicked()>.
Mit diesen Funktionalitäten wird nun zu dem Punkt, auf dem man gerade die Maus hält und die Default-Attacke aktiviert, ein Projektil abgeschossen. Um die Information zu erhalten, auf welcher X- und Y-Position sich die Maus befindet,
 werden die von p5.js vordefinierten Eigenschaft <camera.mouseX> und <camera.mouseY> verwendet.
\\
\begin{lstlisting}[caption=Default-Attacke,language=Java,label=lst:impl:defaultAttack]
    function mouseClicked() {
    // Maus-Position
    let x = camera.mouseX,
        y = camera.mouseY;
    // Sprite wird bei meiner Player-Sprite-Positon erstellt
    projectile = createSprite(myPlayer.sprite.position.x, myPlayer.sprite.position.y, pixelWidth, pixelWidth);
      
    // Geschwindigkeit wird auf die Position der Maus ausgerichtet
    projectile.velocity.x = (x - myPlayer.sprite.position.x);
    projectile.velocity.y = (y - myPlayer.sprite.position.y);
}

\end{lstlisting}

\subsubsection{Movements}
Es gibt 3 fundamentale Bewegungsmöglichkeiten in Scribble-Fight. Springen, links/rechts laufen und 'klettern'. Diese Bewegungen werden im Folgenden genauer erläutert.

\textbf{Springen}
\\
In dem Web-Game springt man mittels Leertaste. Genau wie bei den Items, wird mittels den p5.js Methoden der User-Input ermittelt.
Bei dem Springbewegung wird einfach die vertikale Geschwindigkeit des Player-Sprites so verändert, dass dieser etwas nach oben springt.
\\
\begin{lstlisting}[caption=Jumping,language=Java,label=lst:impl:jumping]
    // check if user pressed spacebar
    if (keyWentDown(32)) {
        jump()
    }

    function jump() {
    // user is only allowed to jump 2 times (it resets when touching the ground)
    if (!(JUMP_COUNT >= MAX_JUMP)) {
        // make the user fly up a bit (JUMP is a global variable)
        myPlayer.sprite.velocity.y = -JUMP;
        JUMP_COUNT++;
    }
}
\end{lstlisting}

\textbf{Links/Rechts Laufen}
\\
Das Prinzip des Links oder Rechts Bewegens ist sehr simpel. Es wird einfach die horizontale Geschwindigkeit des Player-Sprites auf eine konstante Variable gesetzt.
Wenn man sich nach rechts bewegt, ist diese Konstante positiv, bei einer Linksbewegung negativ. Im Gegensatz zur Springbewegung wird diesmal aber die Methode <keyIsDown(key)> verwendet, und nicht <keyWentDown(key)>.
Der Grund dafür ist, dass die Bewegung so lange anhalten soll, wie der User die Taste drückt, und nicht nur einmal pro Tastendruck.

\begin{lstlisting}[caption=Links/Rechts-Movement,language=Java,label=lst:impl:moving]
    //A
    if (keyIsDown(65)) {
        moveLeft()
    }
    //D
    if (keyIsDown(68)) {
        moveRight()
    }

    // SPEED is a global variable
    function moveLeft() {
    myPlayer.sprite.velocity.x = -SPEED;
    }

    function moveRight() {
    myPlayer.sprite.velocity.x = SPEED;
    }
\end{lstlisting}

\textbf{Bewegung auf der Spielumgebung}
\\
Die Bewegung auf der Spielumgebung wird durch die Methode <collisions()> bestimmt. Diese wird in der draw-Methode aufgerufen und wird somit 60 mal die Sekunde ausgeführt.
Berührt der Sprite des Players nichts, fällt er er mit konstanter Beschleunigung nach unten.
Findet jedoch eine Kollision mit der Spielumgebung statt, dann wird überprüft, welche Art von Berührung gerade stattfindet:

\begin{compactitem}
    \item Falls Berührung seitlich: Player-Sprite bekommt eine Klettergeschwindigkeit und behält diese so lange, wie die Berührung stattfindet
    \item Falls Berührung unten: Die vertikale Geschwindigkeit des Player-Sprites wird auf 0 gesetzt und der Sprung-Counter zurückgesetzt
    \item Falls Berührung oben: Mit einer Berührung die zwischen Spielumgebung und Sprite stattfindet, kann man nicht klettern noch wird der Sprung-Counter zurückgesetzt
\end{compactitem}

\begin{lstlisting}[caption=Bewegung auf der Spielumgebung,language=Java,label=lst:impl:collisions]
    // check for collisions
    if (myPlayer.sprite.collide(environment)) {
      // if the collision is on the side, the sprite will start "climbing" with a certain speed
      if (myPlayer.sprite.touching.left || myPlayer.sprite.touching.right) {
        myPlayer.sprite.velocity.y = CLIMBINGSPEED;
      }
      // standing on the environment
      if(myPlayer.sprite.touching.bottom) {
        myPlayer.sprite.velocity.y = 0; 
      }
      // jump count gets only reset when the collision is not on the top of the player-sprite
      if (!myPlayer.sprite.touching.top) {
        JUMP_COUNT = 0;
      }
    }
\end{lstlisting}

\textbf{Knockback-Bewegung} \\
Wenn man von einem Projektil getroffen wurde, wird der eigene Player-Sprite für kurze Zeit bewegungsunfähig und prallt von der Spielumgebung ab.
Wie lang dieses Knockback-Movement andauert, kommt auf die Art des Projektils und auf den Wert des Knockbacks des Players an.
Soll der Player-Sprite also nun diese Bewegung ausführen, wird das mit einer Funktion namens <sendHimFlying()> bewerkstelligt.
Bevor diese aufgerufen wird, muss noch wie der Countdown, wie lange der Sprite nun in dieser Bewegung bleiben soll, festgelegt werden. Bei jedem draw-Zyklus wird dieser Countdown um den Wert eins verringert.
Hinzu kommt noch, dass wenn man also getroffen wurde, man kurz etwas verlangsamt wird. Es soll so wirken, als wäre man gerade etwas betäubt worden.
\begin{lstlisting}[caption=Knockback-Bewegung,language=Java,label=lst:impl:knockbackMov]
// before function gets called, make sure to set flying to true and set a flying-duration
function sendHimFlying() {
  if (flying) {
    timeFlying--;
    //slowdown 
    if (timeFlying <= flyingDuration / 2 && timeFlying > 0) {
      if (myPlayer.sprite.velocity.x > 0) { myPlayer.sprite.velocity.x -= 0.3; }
      if (myPlayer.sprite.velocity.x < 0) { myPlayer.sprite.velocity.x += 0.3; }
      if (myPlayer.sprite.velocity.y > 0) { myPlayer.sprite.velocity.y -= 0.3; }
      if (myPlayer.sprite.velocity.y < 0) { myPlayer.sprite.velocity.y += 0.3; }
    }
    // flying-duration is over
    if (timeFlying == 0) {
      flying = false;
    }
  }
}
\end{lstlisting}


\textbf{Richtungswechsel des Sprites} \label{directionChange}
\\
Ein weiterer wichtiger Aspekt bei der Bewegung des Player-Sprites ist, dass sich auch die Orientierung des Bildes ändern muss, wenn dieser die Richtung wechselt.
Auch für diese Problemstellung stellt p5.play.js eine Lösung zu Verfügung. Mit der Methode <mirrorX()> wird der Sprite entlang seiner vertikalen Achse gespiegelt.
Jedes mal, wenn der User nun also die Richtung seines Player-Sprites wechselt, wird auch der Sprites passend seiner Bewegung gespiegelt.

\begin{lstlisting}[caption=Sprite Richtungswechsel,language=Java,label=lst:impl:mirrorSprite]
    function mirrorSprite() {
        // A
        if (keyWentDown(65)) {
            mirrorSpriteLeft()
        }
        // D
        if (keyWentDown(68)) {
            mirrorSpriteRight()
        }
    }
    
    function mirrorSpriteLeft() {
        // if the mirrorX attribute is 1, then the sprite is looking to the right
        if (myPlayer.sprite.mirrorX() === 1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "left";
        }
    }
    
    function mirrorSpriteRight() {
        // if the mirrorX attribute is 1, then the sprite is looking to the left
        if (myPlayer.sprite.mirrorX() === -1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "right";
        }
    }
\end{lstlisting}

\subsubsection{Wie gewinne ich?}
Um in Scribble-Fight zu gewinnen, muss man seinen Gegner/seine Gegner drei mal erfolgreich von der Spielumgebung schießen, so, dass der Sprite des Gegners ins Nichts fällt.
Dies ist durch die Attacken, die in Kapitel \ref{impl:items} genau beschreiben werden, möglich. 
Um zu überprüfen, ob der Sprite nun hinuntergefallen und somit 'gestorben' ist, wird in der draw-Methode die Funktion <deathCheck()> aufgerufen.
Diese hat einige Aufgaben:
\begin{compactitem}
    \item Überprüfen ob sich der Player-Sprite außerhalb des Bildschirms befindet
    \item Falls ja, überprüfen ob der Player noch mindestens ein Leben hat
    \item Falls der Player keine Leben mehr hat, wird sein Sprite zerstört
    \item Hat der Player noch weitere Leben, dann wird er nach drei Sekunden an einem zufälligen Punkt, an dem er nicht direkt wieder aus dem Bildschirm fällt, gespawned
    \item Wird der Player respawned, werden ihm alle seine Items, die er eventuell noch hatte, wieder genommen
    \item Wird der Player respawned, wird sein Knockback wieder zurückgesetzt
\end{compactitem}

Vereinfacht sieht die Methode also so aus:

\begin{lstlisting}[caption=Überprüfung nach Toden,language=Java,label=lst:impl:deathCheck]
function deathCheck() {
    // check if sprite has fallen outside of the monitor
    if (myPlayer.sprite.position.y - player_height > windowHeight && !respawnTime) {
        youDied();
    }
}

function youDied() {
    myPlayer.removeItem();
    myPlayer.death++;
    myPlayer.knockback = 0;
    respawnTime = true;

    // after 3 seconds the player gets respawned on a location, if he still has at least one live left
    setTimeout(() => {
        if (myPlayer.death < 3) {
            myPlayer.sprite.position.x = xCoordinates[Math.floor(Math.random() * xCoordinates.length)];
            myPlayer.sprite.position.y = 0;
            respawnTime = false;
        }
    }, 3000);
}
\end{lstlisting}

Außerdem zählt es auch als Tod, wenn der Knockback des eigenen Players über 100 ansteigt. Dies wird mit der <fatalHit()>-Methode überprüft.
Diese Methode wird immer dann aufgerufen, wenn der eigene Player von irgendeinem Projekil getroffen wurde.
\begin{lstlisting}[caption=Fatal Hit,language=Java,label=lst:impl:falatHit]
    function fatalHit() {
        if (myPlayer.knockback >= 100) {
            youDied();
        }
    } 
\end{lstlisting}

\subsubsection{Erstellung der Spielumgebung} \label{impl:Spielumgebung}
Um sich auch auf dem Bild, das der User gezeichnet hat, bewegen zu können, muss einiges gemacht werden. Mittels Objekterkennung kann das Bild abfotografiert, 
und daraus ein Array mit Bildaten erstellt werden, aus dem man dann wiederum die Spielumgebung kreiert. Wie genau dieser Array zustande kommt, wird in Kapitel TODO beschrieben.
\\
\begin{lstlisting}[caption=Vereinfachte Darstellung eines Bilddaten-Arrays,language=Java,label=lst:impl:bilddaten]
    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [255, 255, 255, 0], [252, 252, 252, 0], [251, 251, 251, 0],
    [248, 248, 248, 0], [249, 249, 249, 0], [247, 247, 247, 0],
    [255, 255, 255, 0], [240, 240, 240, 0], [250, 250, 250, 0],
    [174, 174, 174, 0], [255, 255, 255, 0], [173, 173, 173, 0],
    [226, 226, 226, 0], [255, 255, 255, 0], [253, 253, 253, 0],
    [163, 163, 163, 0], [254, 254, 254, 0], [255, 255, 255, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [[0, 0, 0, 0],
\end{lstlisting}

Desto genauer dieser Array ist, desto genauer werden auch die Hitboxen der Spielumgebung.
Hat ein Eintrag des Arrays an Stelle vier mehr als 0 als Wert, wird dort ein Pixel erstellt. Das liegt daran, dass an der vierten Stelle eines solchen Eintrags die Opacity der Bildstelle angegeben wird. Das bedeutet, jemand hat dort etwas gezeichnet.
Natürlich muss der Sprite-Pixel noch einen richtigen X- und Y-Wert bekommen. Diese Koordinate muss auch mit dem Punkt des Bildes übereinstimmen, an den der Sprite als Hitbox agieren soll.
Aus Perfomance-Gründen (Es wird durchgehend auf Kollidierung zwischen Player und Spielumgebung geprüft) werden die Sprite-Pixel entlang der X-Achse noch zusammengefasst.
Wurden nun alle Sprite-Pixel ausfindig gemacht, mit richtigen Koordinaten versehen und entlang der horizontalen Achse zusammengefasst, werden alle einer p5-Group-Variable hinzugefügt.
Das macht das Überprüfen auf Kollision sehr leicht. \\
Die nächsten drei Bilder sollen den Ablauf bildlich darstellen.

Zuerst hat man das originale, vom User gezeichnete Bild.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing.PNG}
    \caption{Originale Zeichnung}
\end{figure}

Daraus erhält man nun druch Objekterkennung einen Array aus den Bilddaten. Wenn man nun aber einfach mit diesem Array 
die Pixel für die Spielumgebung erstellt, sind diese noch viel zu klein und an der falschen Position.
\\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing2.PNG}
    \caption{Bilddaten-Array bildich dargestellt}
\end{figure}

Um die richtigen Koordinaten für die Sprite-Pixel zu bestimmen, werden noch einige andere Faktoren miteinbezogen und daraus dann die richtige Position der Pixel am Bildschirm ermittelt.
Außerdem werden sie noch entlang der X-Achse kombiniert.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{pics/simpleDrawing3.PNG}
    \caption{Spielumgebung}
\end{figure}

Natürlich werden dann diese Sprites versteckt. Es soll ja so wirken, also würde sich der User auf dem, was er gerade gezeichnet hat, bewegen können.
Im Folgenden wird der Algorithmus zum Aufbereiten der Spielumgebung vereinfacht dargestellt. 
\begin{lstlisting}[caption=Erstellen der Spielumgebung,language=Java,label=lst:impl:createEnv]
    environment = new Group();
    // looping through image data array
    for (let i = 0; i < pixel_clumps.length; i++) {
      sprite_pixels[i] = [];
      for (let j = 0; j < pixel_clumps[0].length; j++) {
        if the value is greater than 0, then something has been drawn there
        if (pixel_clumps[i][j][3] > 0) {
          //if the last value in the array is not undefined, we can merge the sprite-pixels
          if (sprite_pixels[i][j - 1] !== undefined) {
            same_x_counter++;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth + faktorY, pixelWidth * same_x_counter, pixelWidth);
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
            // remove the last value, because it has been replaced by a new sprite, with more width
            sprite_pixels[i][j - 1].remove();
            sprite_pixels[i][j - 1] = undefined;
          } else {
            same_x_counter = 1;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth + faktorY, pixelWidth, pixelWidth); 
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
          }
        }
      }
    }
\end{lstlisting}

\subsubsection{Item-Spawns}
Alle 10 Sekunden wird 1 Item gespawned.
Es wird an oberster Stelle des Bildschirms kreiert (y-Koordiante = 0); die x-Position dieses Items wird dann zufällig ausgewählt. 
Wichtig dabei ist jedoch, dass das Items auf keiner Position spawnen darf, bei der es einfach oben auftaucht und dann aus dem Bildschirm fällt.
Wie genau man zu diesen x-Koordiaten kommt, wird in Kapitel \ref{impl:xCoordinates} genau beschrieben. 
Damit man Items voneinder unterscheiden kann, wird jede Art von Item farblich gekennzeichnet:

\begin{compactitem}
    \item Rot: Bomb
    \item Blau: Black-Hole
    \item Gelb: Piano
    \item Orange: Mine
    \item Grün: Size-Reduction
\end{compactitem}

Den Input, wann ein Item genau erstellt wird, (muss bei jedem User der gerade spielt gleich sein!) liefert der Server. Genauere Details wie der Server von Scribble-Fight funktioniert, findet man in Kapitel TODO
\\

\begin{lstlisting}[caption=Erstellen eines Items,language=Java,label=lst:impl:createItem]
funciton createItem(data) {
    // number between 1-5 from the server to create a random item
    let num = data.num;
    // random x-Coordinate from the server
    let x = data.x
    // this equation gets you the highest point of the map
    let y = (windowHeight - ImageHeight) / 2;
    // if x = -1, something on the server-side went wrong
    if (x != -1) {
        // itemSize is a global variable
        switch (num) {
            case 1:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "bomb";
                break;
            case 2:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "black_hole";
                break;
            case 3:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "piano";
                break;
            case 4:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "mine";
                break;
            case 5:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "small";
                break;
        }
        i.dropped = false;
        items.push(i);
    }
\end{lstlisting}

Nachdem nun das Item erstellt wurde, braucht dieses natürlich auch so wie zum Beispiel die Projektile oder der Player eine eigene Physik-Methode. Diese wird, so wie die anderen Physik-Methoden auch, in der Draw-Methode aufgerufen.
Die Methode funktioniert so, dass das Item so lange fällt, bis es irgenwo auf der Spielumgebung landet. Jeder Player kann das Item berühren und somit eine neue Fähigkeit bekommen.

\begin{lstlisting}[caption=Item-Physik,language=Java,label=lst:impl:itemPhy]
    function itemPickUp() {
        if (items.length > 0) {
            items.forEach(item => {
                // if the item collides with the environment, the dropped-attribute becomes true
                if(item.collide(environment)) {
                    item.dropped = true;
                }
                // if the item has not landed anywhere, let it fall 
                if(!item.dropped) {
                    item.velocity.y -= GRAVITY;
                }
    
                // if I collide with the item, I get a new ability depending on the type of the item and the item gets deleted
                if (item.overlap(myPlayer.sprite)) {
                    myPlayer.item[item.type] = new Item(item.type);
                    deleteItem(item);
                }
        }
    }
    \end{lstlisting}

\textbf{Bestimmung von gültigen X-Koordinaten} \label{impl:xCoordinates}
\\
Mit gültiger X-Koordinaten sind jene X-Koordinaten gemeint, bei denen ein Sprite erstellt werden kann, und man sich sicher sein kann, dass der gespawnte Sprite auf der Spielumgebung landen wird und nicht einfach aus dem Bildschirm fliegt.
Um den Algorithmus verstehen zu können, muss man wissen, wie die Spielumgebung erstellt wird und was ein Pixel-Width ist. Dies wird in Kapitel \ref{impl:Spielumgebung} beschrieben.
Bei dem Algorithmus wird zuerst überprüft, auf welchen Stellen Sprite-Pixel vorhanden sind. Von diesen kann schon der Mittelpunkt als gültige X-Koordiaten genommen werden, solange dieser Pixel eine gewisse Breite aufweist. 
Doch damit bei einem sehr breiten Pixel nicht nur eine einzige X-Koordinate ausgewählt wird, wird schrittweise überprüft, ob noch Stellen vor oder hinter dem Mittelpunkt des Sprites in Frage kommen.
Dazu wird dieser Sprite-Pixel nach vorne und nach hinten abgetastet, ob noch genügend Platz da ist, ein Item dort landen zu lassen. 
Es können höchstens halb so viele X-Koordiaten pro Sprite-Pixel ausgewählt werden, wie der Pixel (in Pixel-Width gemessen) breit ist. 
Die Funktion wird im Setup von Scribble-Fight aufgerufen. 

\begin{lstlisting}[caption=Bestimmung gültiger X-Koordinaten,language=Java,label=lst:impl:xCoords]
    function getXCoordinates() {
        let sprite;
        // looping through the sprite_pixel array
        for (let i = 0; i < sprite_pixels.length; i++) {
            for (let j = 0; j < sprite_pixels[i].length; j++) {
                sprite = sprite_pixels[i][j];
                // if the sprite variable is not undefined, it means a sprite exists there
                // the sprite hast to be a width of at least 4 times the normal pixel width
                if (sprite !== undefined && sprite.width >= pixelWidth * 4) {
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the right of the center)
                    for (let index = 0; index < sprite.width / 2; index += pixelWidth * 2) {
                        if (sprite.position.x + index < sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index;
                            xCoordinates.push(x);
                        }
                    }
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the left of the center)
                    for (let index = sprite.width; index > sprite.width / 2; index -= pixelWidth * 2) {
                        if (sprite.position.x + index > sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index - sprite.width;
                            xCoordinates.push(x);
                        }
                    }
                    // doing this eliminates duplicates
                    xCoordinates = Array.from(new Set(xCoordinates));
                }
            }
            return xCoordinates;
        }
    }
\end{lstlisting}




\subsection{Server [R]}
Der Server von Scribble-Fight ist ein einfacher Web-Server, der mit node.js und express.js umgesetzt wurde. 
Dieser hostet statische Files, auf denen sich der Code für das Frontend befindet (HTML Files, p5.js library, etc).
Viele Teile dieses Codes werden im vorherigen Kapitel detailliert erklärt. 
Durch SocketIO können multiple Clients eine Verbindung mit dem Server aufbauen.
So wird es ermöglicht, dass man von unterschiedlichen Netzwerken aus gemeinsam spielen kann. 

\subsubsection{Erstellen des Servers}
Ein node.js Server ist einfach zu erstellen. Man benötigt eigentlich nur zwei Voraussetzungen:

\begin{compactitem}
    \item {Eine funktionierende Node.js-Version}
    \item Java-Script Grundlagen
\end{compactitem}

Ist dies gegeben, kann man einfach einen neuen Ordner erstellen, in diesen wechseln und den Befehl \texttt{npm init} ausführen. 
Dort wird dann ein package.json File für das Node-Projekt erstellt. Nähere Infos zu diesem File findet man in Kapitel \ref{NPM}.
Danach kann man einfach entweder durch eine Entwicklungsumgebung ein neues Java-Script File erstellen, oder man benutzt im Terminal den Befehl \texttt{touch server.js}.
In dem Backend von Scribble-Fight werden express.js und SocketIO benutzt, deshalb muss man die Befehle \texttt{npm install express --save} für express.js, und
\texttt{npm install socket.io} für SocketIO im Terminal ausführen. Dies installiert die Module und fügt die Dependencies zu dem package.json File hinzu. 

Wurde all das berücksichtigt, wird jetzt die Logik des server.js-Files umgesetzt. Zuerst wird eine Instanz von express.js erstellt. 
Danach wird ein HTTP-Server-Objekt und eine SocketIO Instanz angelegt, die das HTTP-Server-Objekt als Paramter nimmt. Zusätzlich wird noch Cross-Origin Resource Sharing freigegeben. 
Der Code sieht also so aus: 

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    var express = require("express");
    var app = express();
    var http = require("http").createServer(app);
    var io = require("socket.io")(http, {
        cors: {
            origin: '*',
        }
    });
\end{lstlisting}

Das war aber nur ein Teil, um einen funktionierenden SocketIO-Webserver zu erstellen. Bei unserem Web-Game müssen, wie vorher schon erwähnt, das Frontend als statische Files gehostet werden.
Für dieses Problem wurde das Paths-Module von node.js verwendet. Dieses stellt Funktionen für das Arbeiten mit File-und Directory-Pfaden zur Verfügung. Darauf zugreifen kann  man mit:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    const path = require('path');
\end{lstlisting}

Nun können die Files einfach mit \\

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    // path.join is used to get the right path 
    app.use(express.static(path.join(__dirname, '/../p5_frontend/src')));
\end{lstlisting}

gehostet werden. (Diese befinden sich in dem Folder <src>);

Als letzten Schritt wird noch der Port bei dem HTTP-Server-Objekt angegeben, im Fall von unserem Server ist dieser 3000. 
\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    // Server is listening on port 3000
    http.listen(3000);
\end{lstlisting}

Ist das alles abgeschlossen, wird nun die SocketIO Logik umgesetzt. 

\subsubsection{SocketIO Logik}
Der nun funktionierende Web-Server soll nun SocketIO-Verbindungen, die vom Browser kommen, annehmen können.
Mit der SocketIO Instanz, die im letzten Abschnitt erstellt worden ist, kann dieses Problem sehr leicht gelöst werden:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    io.sockets.on('connection', newConnection);

    function newConnection(socket) {
        // LOGIC COMES HERE
    }
\end{lstlisting}

Findet nun eine Verbindung zu dem Server von einem Client statt, wird die Methode <newConnection(socket)> aufgerufen. 
Als Paramter dieser Methode bekommt man eine socket-Instanz, die sehr viele Informationen und Funktionalitäten der gerade bestehenden Verbindung enthält.
Wie der Client eine Verbindung zu diesem Server aufbauen kann, ist von Programmiersprache zu Programmiersprache unterschiedlich. Im Frontend von Scribble-Fight wird Java-Scritp benutzt. 

\textbf{SocketIO im Frontend}

Um im Frontend eine SocketIO-Verbindung aufzubauen, wird zuerst in dem index.html File die SocketIO Library verlinkt:
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // link SocketIO in index.html
    <script src="https://cdn.socket.io/4.1.2/socket.io.min.js"></script>
\end{lstlisting}

Jetzt kann einfach eine neue Socket-Instanz erstellt werden mit der man Events empfangen, aber auch aussenden kann. 
Da der Server von Scribble-Fight nicht mehr lokal läuft, sondern auf einem Kubernetes-Cluster, wird hierbei noch ein Pfad definiert, um eine korrekte Instanz zu erstellen.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    var socket = io({
        path: "/t.rafetseder/scribble-fight/socket.io"
      }); 
\end{lstlisting}

Würde man einfach den Befehl \texttt{io()} benutzen, würde SocketIO die Pfad-Paramter der derzeiten Domaine einfach ignorieren. 
\\
Nun kann man mit dem Befehl
\\
\texttt{socket.on('event',funciton)} Events empfangen, und mit \texttt{socket.emit('event')} Events auslösen.

\textbf{SocketIO Events} \\
Nachdem nun eine aufrechte Verbindunge hergestellt werden konnte, gibt es 10 Events, die passieren können. 
\begin{compactitem}
    \item Ein neuer Spieler soll erstellt werden
    \item Abruf von schon bestehenden Spielern
    \item Die Position von meinem Sprite soll geupdatet werden
    \item Die Richtung, in die mein Sprite schaut, soll geupdatet werden
    \item Ein Item wurde aufgehoben, also soll es bei jedem entfernt werden
    \item Jemand hat eine Attacke ausgeführt, also soll bei jedem ein Projektil erstellt werden
    \item Jemand hat einen Kill erzielt
    \item Ein Spieler wurde von einem Projektil getroffen, das heißt das Projektil, das getroffen hat, muss bei jedem entfernt werden
    \item Jemand ist gestorben
\end{compactitem}

Diese Events werden im Folgenden genau erklärt. 

\textbf{Erstellen eines neuen Spielers und Abrufen von vorhandenen Spieler} \\
Führt man das Frontend des Web-Games aus, stellt dieses sofort eine Verbindung mit dem Sever her. Um nun schon vorhandene Spieler, die gerade auch verbunden sind zu erhalten, wird ein Event <getPlayers> emittiert.
Danach muss natürlich dem Server noch mitgeteilt werden, dass man nun selbst auch eine spielbare Figur erhlaten möchte. Dies wird mit dem <newPlayer>-Event bewerkstelligt.
Wird nun das Event <newPlayer> vom Server ausgelöst, wird ein neues Player-Objekt dem Player-Array des Frontends hinzugefügt. Der Konstruktur von diesem Player-Objekt benötigt nur einen Sprite, der auch neu erstellt wird.
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // listen to an event from the server
    socket.on('newPlayer',createNewPlayer);
    // get existing players
    socket.emit('getPlayers');
    // create my own player
    socket.emit('newPlayer');

    function createNewPlayer(data) {
        // new player gets added an new sprite is created in the middle of the map
        players[data.id] = new Player(createSprite(ImageWidth / 2,ImageHeight / 2, player_width, player_height));
    }
\end{lstlisting}

Im Server sieht das Ganze etwas komplizierter aus. Grundsätzlich speichert der Server alle Player-Objekte in einem Map-Objekt ab.
Die ID für jedes dieser Player-Objekte dient einfach die ID der Socket-Verbindung. Will ein Client nun alle schon vorhandenen Spieler, wird die Map (falls Spieler vorhanden) durchlaufen, und die ID von jedem der Spieler an den anfragenden Client geschickt.
Dieser erstellt dann einen neuen Player / mehrere neue Player mit der dazugehörigen ID.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('getPlayers',sendPlayers);

    // the object players is the map that has the player-objects saved
    function sendPlayers() {
        if (players.size > 0) {
            players.forEach((values, keys) => {
                let data = {
                    id: values.id,
                }
                socket.emit('newPlayer', data);
            })
        }
    }
\end{lstlisting}

Nachdem nun der Server alle schon vorhanden Spieler dem Client mitgeteilt hat, muss noch ein neuer Spieler für diesen Client erstellt werden. 

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('newPlayer',createPlayer);  

    function createPlayer() {
        players.set(socket.id, new Player(socket.id));
        let data = {
            id: socket.id,
        }
        // im using io.emit() so it sends to everyone, including the client that triggered the event
        io.emit('newPlayer', data);
    }
\end{lstlisting}

Der Client erstellt nun genau gleich wie bei dem <getPlayers>-Event den Spieler.

\textbf{Update Position and Update Direction}

Die Postion des Sprites von jedem Spieler soll in jedem Draw-Zyklus geupdatet werden. Die Orientierung des Sprites soll nur dann aktualisiert werden, wenn der Spieler die Richtung seines Sprites wechselt. (Beschrieben in Kapitel \ref{directionChange})
Leider ergibt sich beim Aktualisieren von Positionen von Sprites ein Problem. Die Koordinaten in p5.js weden in Pixel angeben. Das bedeuet, haben unterschiedliche Client unterschiedlich große Endgeräte, befinden sich Sprites mit gleichen Koordinaten an unterschiedlichen Stellen. 

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/pixelDiff.PNG}
    \caption{Pixel-Unterschied}
\end{figure}

Aus diesem Grund kann man nicht einfach nur die rohen Koordinaten an alle Clients schicken, muss muss sie in Relation zu dem Bildschirm des Endgeräts und der Größe der Map, also dem Bild auf dem gerade gespielt wird, setzen.
Der Code am Ende von jedem Draw-Zyklus sieht also so aus:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    let transferX = (myPlayer.sprite.position.x - (windowWidth - ImageWidth) / 2) * originalBildBreite / neueBildBreite;
    let transferY = (myPlayer.sprite.position.y - (windowHeight - ImageHeight) / 2) * originalBildHoehe / neueBildHoehe;
    relPosData = {
      x: transferX,
      y: transferY
    }
      socket.emit('update', relPosData);
\end{lstlisting}

Im Server werden diese Koordinaten einfach zusammen mit der passenden ID des Players an alle Spieler verteilt:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

socket.on('update',updatePosition)

    function updatePosition(data) {
        let posData = {
            x: data.x,
            y: data.y,
            id: socket.id
        }
        // with socket.broadcast, everyone except the one who triggered the event gets the data
        socket.broadcast.emit('updatePosition', posData);
    }
\end{lstlisting}

Empfängt ein Client die Koordinaten, muss er diese dann wieder für sein Endgerät richtig umwandeln: 


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

socket.on('updatePosition',updatePosition);

    function updatePosition(data) {
        players[data.id].sprite.position.x = 
        data.x * neueBildBreite / originalBildBreite + (windowWidth - neueBildBreite) / 2;

        players[data.id].sprite.position.y = 
        data.y * neueBildHoehe / originalBildHoehe + (windowHeight - neueBildHoehe) / 2;
    }
\end{lstlisting}

Zum Glück ist das Aktualisieren von der Richtung des Sprites viel leichter. Dort spielt es keine Rolle, wie groß das Endgerät ist. 
Beim Drücken von A oder D auf der Tastatur, wird jetzt einfach ein Event getriggered, dass die Richtung des Sprites bei jedem verbundenen Spieler ändert.


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // A
    if (keyWentDown(65)) {
        socket.emit('updateDirection', 'left');
    }
    // D
    if (keyWentDown(68)) {
        socket.emit('updateDirection', 'right');
    }
\end{lstlisting}

Im Server wird die Information nun einfach an alle Clients verteilt:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
   socket.on('updateDirection',updateDirection);

   function updateDirection(data) {
    let dataWithId = {
        id: socket.id,
        direction: ""
    }
        if (data == "left") {
            dataWithId.direction = "left";
            socket.broadcast.emit('updateDirection', dataWithId);
        } else if (data == "right") {
            dataWithId.direction = "right";
            socket.broadcast.emit('updateDirection', dataWithId);
        }
}
\end{lstlisting}

Wird vom Client nun das <updateDirection>-Event empfangen, wird einfach die Orientierung des Sprites geändert.















\subsubsection{Node.js [R]}
\subsubsection{SocketIO [R]}
\subsection{Gamephysics [R]}
\subsection{Hitregistration [R]}
\subsection{Collisiondetection [R]}
\subsection{Regeln und Spielablauf [R]}
\section{Deployment [R]}
\setauthor{Rafetseder Tobias}
\subsection{Docker [R]}
\subsection{Leo-Cloud [R]}

% Ben dein teil kommt hier herein

\input{./sections/Jonas/mapandai.tex}


% Siehe tolle Daten in Tab. \ref{tab:impl:data}.

% \begin{table}
%     \centering
%     \begin{tabular}{|lcc|}
%         \hline
%                   & \textbf{Regular Customers} & \textbf{Random Customers} \\ \hline
%         Age       & 20-40                      & \textgreater{}60          \\ \hline
%         Education & university                 & high school               \\ \hline
%     \end{tabular}
%     \caption{Ein paar tabellarische Daten}
%     \label{tab:impl:data}
% \end{table}

% \begin{figure}
%     \centering
%     \includegraphics[scale=0.5]{pics/knuthi.jpg}
%     \caption{Don Knuth -- CS Allfather}
%     \label{fig:impl:knuth}
% \end{figure}

% Siehe und staune in Abb. \ref{fig:impl:knuth}.
% \lipsum[6-9]
% Dann betrachte den Code in Listing \ref{lst:impl:foo}.

% \begin{lstlisting}[language=Python,caption=Some code,label=lst:impl:foo]
% # Program to find the sum of all numbers stored in a list (the not-Pythonic-way)

% # List of numbers
% numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]

% # variable to store the sum
% sum = 0

% # iterate over the list
% for val in numbers:
%     sum = sum+val

% print("The sum is", sum)
% \end{lstlisting}