\section{Web-Game [R]}
\setauthor{Rafetseder Tobias}
\subsection{Frontend [R]}
Für die Umsetzung des Frontends wird p5.js beziehungsweise p5.play.js verwendet.
Eine detaillierte Beschreibung zu diesen JavaScript-Bibliotheken und wie sie in ein Projekt eingebunden werden kann, wird in Kapitel \ref{subsection:p5js} genau beschrieben.
p5.play.js basiert auf einer Sprite Klasse. Diese Sprite-Klasse hat einige praktische vordefinierte Funktionen für zum Beispiel Collisiondetection oder Animation-Support.
Um einen Sprite zu erstellen, wird einfach die Funktion createSprite() aufgerufen.
\\
\begin{lstlisting}[language=Java,label=lst:impl:createSprite]
    function setup() {
        createCanvas(1920,1080);
        // create a sprite
        createSprite(50,50,30,30);
    }

    function draw() {
        // draw all the sprites added to the sketch so far
        // the positions will be updated automatically at every cycle
        drawSprites();
    }
\end{lstlisting}


Es ist zu beachten, dass die ersten 2 Parameter der Funktion jeweils die Position am Bildschirm in Pixel angeben, und die letzten 2 die Breite und die Höhe definieren.
Das Ergebnis:
\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/simpleSprite.PNG}
    \caption{Einfacher Sprite}
\end{figure}

Es ist noch nicht viel zu sehen, nur ein simpler Sprite, der default-mäßig ein einfaches Rechteck mit zufälliger Farbe auf einer Position erschienen ist.
Für den Spieler, der in dem Canvas angezeigt werden soll, wird diese Sprite-Klasse noch um ein paar Attribute erweitert:

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/playerClass.PNG}
    \caption{Player-Klasse}
\end{figure}

Zum Erstellen der Player-Klasse wird zwar ein Sprite benötigt, damit der Player am Bildschirm angezeigt wird, aber es werden noch einige Attribute ergänzt:
\begin{compactitem}
    \item id: Zur eindeutigen Identifizierung
    \item knockback: Wert, der erhöht wird, desto öfter der Spieler getroffen wird; je höher der Wert, desto weiter wird der Spieler von Projektilen weggestoßen
    \item death: Anzahl, wie oft der Spieler gestorben ist
    \item kills: Anzahl an Kills, die der Spieler gemacht hat (Abschüsse, die dazu geführt haben, dass der Gegner hinuntergefallen ist)
    \item dmgDealt: Anzahl, wie oft der Spieler jemanden getroffen hat
    \item item: Array von Items, die der Spieler gerade besitzt
    \item direction: String, der die Richtung angibt, in die der Spieler gerade schaut (links oder rechts)
\end{compactitem}

Während des Spiels werden auf der Map Items erstellt. Welcher Algorithmus dahinter steckt, wird im Kapitel \ref{impl:xCoordinates} genauer beschrieben.
Es wird zwischen 5 unterschiedlichen Items entschieden. Eine Item-Klasse hat ähnlich wie die Player-Klasse als Hauptbestandteil einen Sprite, doch auch hier werden noch weitere Attribute benötigt.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/itemClass.PNG}
    \caption{Item-Klasse}
\end{figure}

\begin{compactitem}
    \item type: Gibt den Typ des Items an
    \item dropped: Gibt an, ob das Item irgendwo auf der Umgebung gelandet ist
    \item ammo: Anzahl, wie oft der Spieler das Item benutzen kann
\end{compactitem}

Je nachdem, welchen Typ das Item bekommen hat, wird auch die Anzahl wie oft
der Spieler es benutzen kann, verändert.
Wurde es zum Beispiel zum Type "bomb", kann der Spieler 5 Mal eine Bombe werfen.
\\
Bei dem Typ "mine", also einer Mine, kann der Spieler mehrere Minen gleichzeitig legen, deshalb ist das Sprite-Attribut auch ein Array.
Bei den anderen Items kann immer nur ein Sprite davon existieren.




\subsubsection{Die Items}  \label{impl:items}
Grundsätzlich gibt es 5 unterschiedliche Items in ScribbleFight. Je nachdem, welches Item der Spieler aufgesammelt hat, kann er oder sie verschiedene Fähigkeiten aktivieren.
Für jedes Item existiert eine Physik-Methode, die in der Draw-Funktion aufgerufen wird. Diese ist dafür verantwortlich, die physischen Eigenschaften der Items darzustellen (zum Beispiel Gravitation).

\textbf{Keyboard-Access}
\\
Die Items werden alle durch Tasten auf der Tastatur ausgelöst. Durch p5.js kann sehr einfach auf die Tastatur zugegriffen werden.
Mit der p5.js Methode <keyWentDown(Key)> wird überprüft, ob eine Taste gerade gedrückt wurde. (Als Parameter wird der ASCII-Code der gewünschten Taste übergeben)

\begin{lstlisting}[caption=Keyboard-Access,language=Java,label=lst:impl:keyboard-access]
    // E
    if (keyWentDown(69)) {
        bombAttack();
    }
    // Q
    if (keyWentDown(81)) {
        blackHoleAttack();
    }
    // R
    if (keyWentDown(82)) {
        pianoTime();
    }
    // C
    if (keyWentDown(67)) {
        placeMine();
    }
    // F
    if (keyWentDown(70)) {
        makeMeSmall();
    }
\end{lstlisting}

\textbf{Bomb}
\\
\textit{Das Bomben-Item wird mit der Taste <E> aktiviert.}
\\
Durch p5.play.js kann die vertikale Geschwindigkeit eines Sprites mit <sprite.velocity.y> verändert werden. Dadurch kann eine Gravitation simuliert werden.
Außerdem können mit der Methode <sprite.bounce(otherSprite)> Sprites an anderen Sprites oder Gruppen von Sprites 'abspringen'. Dies wird benutzt, damit die Bombe an der Umgebung abprallt.
Danach wird mit <sprite.overlap(myPlayer.sprite)> überprüft, ob eine Bombe mit meinem Spieler-Sprite kollidiert.
Falls ja, wird die Bombe mit <sprite.remove()> entfernt und mein Spieler wird weggestoßen.
Falls nein, wird noch überprüft, ob sich die Bombe außerhalb des Bildschirms befindet, und falls dies zutrifft, wird auch in diesem Fall die Bombe entfernt.
\\

\begin{lstlisting}[caption=Bomb Item Physics,language=Java,label=lst:impl:bombGravity]
    // verringern der vertikalen Geschwindigkeit 
    bomb.velocity.y -= GRAVITY;
    // bombe prallt an der Umgebung ab
    bomb.bounce(environment);

    // kollidert die Bombe mit meinem Player
    if(bomb.overlapSprite(myPlayer.sprite)) {
        // my Player gets knocked back
        myPlayer.sprite.getsThrownAway();
        // bomb gets deleted
        bomb.remove();
    } else if(bombIsOutsideMonitor()) {
        // bomb gets deleted
        bomb.remove();
    }

\end{lstlisting}

\textbf{Black Hole}
\\
\textit{Das Black-Hole-Item wird mit der Taste <Q> aktiviert}.
\\
Wie bei dem Bomben-Item wird auch bei dem Black-Hole-Item Gravitation simuliert. Jedoch nur für eine kurze Zeit, bis das Item in der Luft stehen bleibt und in einem Radius alle Spieler, die sich in diesem Radius befinden, anzieht, und diese auch alle Fähigkeiten nimmt.
Um zu überprüfen, wie lange das Item schon existiert, stellt p5.play.js das <life>-Attribut zur Verfügung. Dieser Wert ist ein Countdown, der sich bei jedem Draw-Zyklus um 1 verringert, bis sich das Item dann bei dem Wert 0 selbst löscht.
Damit das Item funktionieren kann, muss es andere Sprites anziehen können. Dazu wurde die attraction-Funktion von p5.play.js (mit leichten Veränderungen) benutzt:

\begin{lstlisting}[caption=Attraction,language=Java,label=lst:impl:attraction]
    // attraction
    if (myPlayer.sprite.overlap(b)) {
        noGravity = true;
        var angle = atan2(myPlayer.sprite.position.y - b.position.y, myPlayer.sprite.position.x - b.position.x);
        if (myPlayer.sprite.velocity.y >= -pixelWidth && myPlayer.sprite.velocity.y <= pixelWidth) {
          myPlayer.sprite.velocity.x -= cos(angle);
        }
        myPlayer.sprite.velocity.y -= sin(angle);
      }

\end{lstlisting}

Die Black-Hole-Physics Funktion sieht also (vereinfacht) so aus:
\\
\begin{lstlisting}[caption=Black Hole Item Physics,language=Java,label=lst:impl:bombGravity]
    // if the item has reached a certain life, make it static and attract players
    if (b.life <= 400) {
        attraction(b);
        b.velocity.y = 0;
        b.velocity.x = 0;
      }

      // if the item has not reached a certain life, let it bounce off the environment
      if (b.life > 400) {
        b.velocity.y -= GRAVITY;
        b.bounce(environment);
      }

      // if the item is outside of the monitor, delete it
      if (b.position.x > windowWidth || b.position.y > windowHeight || b.life == 0) {
        b.remove();
      }

\end{lstlisting}

\textbf{Piano}
\\
\textit{Das Piano-Item wird mit der Taste <R> aktiviert.}
\\
Das Piano-Item ist, wie der Namen schon vermuten lässt, ein Klavier, das am höchsten Punkt der Map erscheint und nach unten fällt.
Das bedeutet, die y-Koordinate ist 0 und die x-Koordinate ist die selbe wie die, die der Sprite des Spielers hat, der das Piano aktiviert hat.
Bei Kontakt zu einem Spieler oder der Umgebung wird das Klavier zerstört. Zum Überprüfen auf Kollisionen wird die p5.js Methode <sprite.collide(otherSprite)> verwendet.
Diese erhält den Wert \texttt{true}, falls eine Kollisionen zwischen zwei Sprites oder Sprite-Gruppen stattfindet.
\\
\begin{lstlisting}[caption=Piano-Item Physics,language=Java,label=lst:impl:pianoPhy]
    // check for collisions
    if (p.collide(environment)) {
        p.remove();
      } else if (p.overlap(myPlayer.sprite)) {
        myPlayer.sprite.getsThrownAway()
        p.remove();
      }
      p.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Mine}
\\
\textit{Das Minen-Item wird mit der Taste <C> aktiviert.}
Das Minen-Item ist das einzige Item, bei dem der Spieler mehrere Instanzen auf einmal entsenden kann.
Es taucht hinter dem eigenen Player-Sprite auf und fliegt so lange nach unten, bis es auf der Umgebung landet. Erst wenn es wo gelandet ist, wird es 'aktiv'.
Wenn eine Mine aktiviert worden ist, und ein Spieler in Berührung mit dem Item kommt, wird dieser in die Luft gestoßen und die Mine wird gelöscht.
\\
\begin{lstlisting}[caption=Mine-Item Physics,language=Java,label=lst:impl:minePhy]
    // check if mine has landed somewhere (if true: activate mine)
    if (m.collide(environment) && m.touching.bottom) {
        m.set = true;
    }
    if (m.overlap(myPlayer.sprite) && m.set) {
        myPlayer.sprite.getsThrownAway();
        m.remove();
    }
    m.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Size-Reduction}
\\
\textit{Das Size-Reduction-Item wird mit der Taste <F> aktiviert.}
\\
Dieses Item ist das einzige, das keinen eigenen Sprite hat. Das einzige was es macht, ist, den Spieler-Sprite zu verkleinern. Dadurch wird dieser schwieriger zu treffen.
Wird dieses Item aktiviert, so wird der Sprite des Spielers oder der Spielerin verkleinert und ein Counter wird gestartet. Dieser wird alle 60 Frames um eins verringert. Ist der Counter 0, wird der Sprite wieder in seine Originalgröße gebracht.
Der Code, der dies umsetzt, sieht vereinfacht so aus:
\\
\begin{lstlisting}[caption=Size-Reduction,language=Java,label=lst:impl:sizeReduc]
// gets called on key press F
function makeMeSmall() {
  if (doIHaveTheItem()) {
    imSmall = true;
    smallTimer = 10;
  }
}

// gets called in draw function
function smallChecker() {
  if (imSmall) {
    // scale the sprite down at the start of countdown
    if (smallTimer == 10) {
      myPlayer.sprite.scale = 0.6;
    }
    // every second (60 frames), the countdown gets reduced
    if (frameCount % 60 == 0 && smallTimer > 0) {
      smallTimer--;
    }
    // if the countdown is over, rescale the sprite back to the original form
    if (smallTimer == 0) {
      myPlayer.sprite.scale = 1;
      smallTimer = 10;
      imSmall = false;
    }
  }

}
\end{lstlisting}

\textbf{Die Default-Attacke}
\\
\textit{Die Default-Attacke wird mit <Left-Click> aktiviert.}
\\
p5.js bietet sehr einfach die Möglichkeit, auf User-Input zu überprüfen. Das einzige, was nötig ist um zu erkennen, ob der User gerade die linke Maustaste geklickt hat, ist die Funktion <mouseClicked()>.
Mit dieser Funktion wird nun zu dem Punkt, auf dem der Spieler gerade die Maus hält und die Default-Attacke aktiviert, ein Projektil abgeschossen. Um die Information zu erhalten, auf welcher X- und Y-Position sich die Maus befindet,
werden die von p5.js vordefinierten Eigenschaft <camera.mouseX> und <camera.mouseY> verwendet.
\\
\begin{lstlisting}[caption=Default-Attacke,language=Java,label=lst:impl:defaultAttack]
    function mouseClicked() {
    // Maus-Position
    let x = camera.mouseX,
        y = camera.mouseY;
    // Sprite wird bei meiner Player-Sprite-Positon erstellt
    projectile = createSprite(myPlayer.sprite.position.x, myPlayer.sprite.position.y, pixelWidth, pixelWidth);
      
    // Geschwindigkeit wird auf die Position der Maus ausgerichtet
    projectile.velocity.x = (x - myPlayer.sprite.position.x);
    projectile.velocity.y = (y - myPlayer.sprite.position.y);
}

\end{lstlisting}

\subsubsection{Movements}
Es gibt 3 fundamentale Bewegungsmöglichkeiten in ScribbleFight. Springen, links/rechts laufen und 'klettern'. Diese Bewegungen werden im Folgenden genauer erläutert.

\textbf{Springen}
\\
In dem Web-Game kann der Spieler mittels Leertaste springen. Genau wie bei den Item-Aktivierungen, wird mithilfe von p5.js Methoden der User-Input ermittelt.
Bei der Springbewegung wird die vertikale Geschwindigkeit des Spieler-Sprites so verändert, dass dieser etwas nach oben springt.
\\
\begin{lstlisting}[caption=Jumping,language=Java,label=lst:impl:jumping]
    // check if user pressed spacebar
    if (keyWentDown(32)) {
        jump()
    }

    function jump() {
    // user is only allowed to jump 2 times (it resets when touching the ground)
    if (!(JUMP_COUNT >= MAX_JUMP)) {
        // make the user fly up a bit (JUMP is a global variable)
        myPlayer.sprite.velocity.y = -JUMP;
        JUMP_COUNT++;
    }
}
\end{lstlisting}

\textbf{Links/Rechts Laufen}
\\
Das Prinzip des Links oder Rechts Bewegens ist sehr simpel. Es wird die horizontale Geschwindigkeit des Player-Sprites auf eine konstante Variable gesetzt.
Wenn sich der Spieler nach rechts bewegt, ist diese Konstante positiv, bei einer Linksbewegung negativ. Im Gegensatz zur Springbewegung wird diesmal aber die Methode <keyIsDown(key)> verwendet, und nicht <keyWentDown(key)>.
Der Grund dafür ist, dass die Bewegung so lange anhalten soll, wie der User die Taste drückt, und nicht nur einmal pro Tastendruck.

\begin{lstlisting}[caption=Links/Rechts-Movement,language=Java,label=lst:impl:moving]
    //A
    if (keyIsDown(65)) {
        moveLeft()
    }
    //D
    if (keyIsDown(68)) {
        moveRight()
    }

    // SPEED is a global variable
    function moveLeft() {
    myPlayer.sprite.velocity.x = -SPEED;
    }

    function moveRight() {
    myPlayer.sprite.velocity.x = SPEED;
    }
\end{lstlisting}

\textbf{Bewegung auf der Spielumgebung}
\\
Die Bewegung auf der Spielumgebung wird durch die Methode <collisions()> bestimmt. Diese wird in der draw-Methode aufgerufen und wird somit 60 mal die Sekunde ausgeführt.
Berührt der Sprite des Players nichts, fällt er er mit konstanter Geschwindigkeit nach unten.
Findet jedoch eine Kollision mit der Spielumgebung statt, wird überprüft, welche Art von Berührung gerade stattfindet:

\begin{compactitem}
    \item Bei seitlicher Berührung: Player-Sprite bekommt eine Klettergeschwindigkeit und behält diese so lange, wie die Berührung stattfindet
    \item Bei Berührung von unten: Die vertikale Geschwindigkeit des Player-Sprites wird auf 0 gesetzt und der Sprung-Counter zurückgesetzt
    \item Bei Berührung von oben: Der Spieler oder die Spielerin kann weder 'klettern' noch wird der Sprung-Counter zurückgesetzt
\end{compactitem}

\begin{lstlisting}[caption=Bewegung auf der Spielumgebung,language=Java,label=lst:impl:collisions]
    // check for collisions
    if (myPlayer.sprite.collide(environment)) {
      // if the collision is on the side, the sprite will start "climbing" with a certain speed
      if (myPlayer.sprite.touching.left || myPlayer.sprite.touching.right) {
        myPlayer.sprite.velocity.y = CLIMBINGSPEED;
      }
      // standing on the environment
      if(myPlayer.sprite.touching.bottom) {
        myPlayer.sprite.velocity.y = 0; 
      }
      // jump count gets only reset when the collision is not on the top of the player-sprite
      if (!myPlayer.sprite.touching.top) {
        JUMP_COUNT = 0;
      }
    }
\end{lstlisting}

\textbf{Knockback-Bewegung} \\
Wenn der Spieler von einem Projektil getroffen wurde, wird der eigene Player-Sprite für kurze Zeit bewegungsunfähig und prallt von der Spielumgebung ab.
Wie lang dieses Knockback-Movement andauert, kommt auf die Art des Projektils und auf den Wert des Knockbacks des Players an.
Soll der Player-Sprite diese Bewegung ausführen, wird das mit einer Funktion namens <sendHimFlying()> bewerkstelligt.
Bevor diese aufgerufen wird, muss noch der Countdown, wie lange der Sprite nun in dieser Bewegung bleiben soll, festgelegt werden. Bei jedem draw-Zyklus wird dieser Countdown um den Wert eins verringert.
Hinzu kommt, dass wenn der Spieler getroffen wurde, er kurz etwas verlangsamt wird. Es soll so wirken, als wäre er gerade etwas betäubt worden.
\begin{lstlisting}[caption=Knockback-Bewegung,language=Java,label=lst:impl:knockbackMov]
// before function gets called, make sure to set flying to true and set a flying-duration
function sendHimFlying() {
  if (flying) {
    timeFlying--;
    //slowdown but only at the first half of flying-duration
    if (timeFlying <= flyingDuration / 2 && timeFlying > 0) {
      if (myPlayer.sprite.velocity.x > 0) { myPlayer.sprite.velocity.x -= 0.3; }
      if (myPlayer.sprite.velocity.x < 0) { myPlayer.sprite.velocity.x += 0.3; }
      if (myPlayer.sprite.velocity.y > 0) { myPlayer.sprite.velocity.y -= 0.3; }
      if (myPlayer.sprite.velocity.y < 0) { myPlayer.sprite.velocity.y += 0.3; }
    }
    // flying-duration is over
    if (timeFlying == 0) {
      flying = false;
    }
  }
}
\end{lstlisting}


\textbf{Richtungswechsel des Sprites} \label{directionChange}
\\
Ein weiterer wichtiger Aspekt bei der Bewegung des Player-Sprites ist, dass sich auch die Orientierung des Bildes ändern muss, wenn dieser die Richtung wechselt.
Auch für diese Problemstellung stellt p5.play.js eine Lösung zu Verfügung. Mit der Methode <mirrorX()> wird der Sprite entlang seiner vertikalen Achse gespiegelt.
Jedes mal, wenn der User die Richtung seines Player-Sprites wechselt, wird auch der Sprites passend seiner Bewegung gespiegelt.

\begin{lstlisting}[caption=Sprite Richtungswechsel,language=Java,label=lst:impl:mirrorSprite]
    function mirrorSprite() {
        // A
        if (keyWentDown(65)) {
            mirrorSpriteLeft()
        }
        // D
        if (keyWentDown(68)) {
            mirrorSpriteRight()
        }
    }
    
    function mirrorSpriteLeft() {
        // if the mirrorX attribute is 1, then the sprite is looking to the right
        if (myPlayer.sprite.mirrorX() === 1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "left";
        }
    }
    
    function mirrorSpriteRight() {
        // if the mirrorX attribute is 1, then the sprite is looking to the left
        if (myPlayer.sprite.mirrorX() === -1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "right";
        }
    }
\end{lstlisting}

\subsubsection{Wie gewinne ich?} \label{impl:win}
Um in ScribbleFight zu gewinnen, muss der Spieler oder die Spielerin die Gegner drei mal erfolgreich von der Spielumgebung schießen, so, dass der Sprite des Gegners ins 'Nichts' fällt.
Dies ist durch die Attacken, die in Kapitel \ref{impl:items} genau beschreiben werden, möglich.
Um zu überprüfen, ob der Sprite hinuntergefallen und somit 'gestorben' ist, wird in der draw-Methode die Funktion <deathCheck()> aufgerufen.
Diese hat einige Aufgaben:
\begin{compactitem}
    \item Überprüfen ob sich der Player-Sprite außerhalb des Bildschirms befindet
    \item Falls ja, überprüfen ob der Player noch mindestens ein Leben hat
    \item Falls der Player keine Leben mehr hat, wird sein Sprite zerstört
    \item Hat der Player noch weitere Leben, dann wird er nach drei Sekunden an einem zufälligen Punkt, an dem er nicht direkt wieder aus dem Bildschirm fällt, neu erstellt - der Vorgang wird "to respawn" genannt
    \item Wird der Player respawned, werden ihm alle seine Items, die er eventuell noch hatte, wieder genommen
    \item Wird der Player respawned, wird sein Knockback wieder zurückgesetzt
\end{compactitem}

Vereinfacht sieht die Methode also so aus:

\begin{lstlisting}[caption=Überprüfung nach Toden,language=Java,label=lst:impl:deathCheck]
function deathCheck() {
    // check if sprite has fallen outside of the monitor
    if (myPlayer.sprite.position.y - player_height > windowHeight) {
        youDied();
    }
}

function youDied() {
    myPlayer.removeItem();
    myPlayer.death++;
    myPlayer.knockback = 1;

    // after 3 seconds the player gets respawned on a location, if he still has at least one live left
    setTimeout(() => {
        if (myPlayer.death < 3) {
            myPlayer.sprite.position.x = xCoordinates[Math.floor(Math.random() * xCoordinates.length)];
            myPlayer.sprite.position.y = 0;
        }
    }, 3000);
}
\end{lstlisting}

Außerdem zählt es auch als Tod, wenn der Knockback des eigenen Players über einen gewissen Wert ansteigt. Dies wird mit der <fatalHit()>-Methode überprüft.
Diese Methode wird immer dann aufgerufen, wenn der eigene Player von irgendeinem Projektil getroffen wurde.
\begin{lstlisting}[caption=Fatal Hit,language=Java,label=lst:impl:fatalHit]
    function fatalHit() {
        if (myPlayer.knockback > MAX_KNOCKBACK) {
            youDied();
        }
    } 
\end{lstlisting}
Ein Indikator, ob der Spieler gut abgeschnitten hat, sind die Kills, die er erzielen konnte.
In ScribbleFight kann der Spieler Kills sammeln, indem er Gegner mit jeglicher Art von Projektil trifft, und dieser innerhalb von 3 Sekunden aus der Spielumgebung fliegt.
Dies funktioniert so, dass wenn jemand den player-Sprite des Spielers trifft, in dem Player-Objekt abgespeichert wird, welcher Spieler den player-Sprite gerade getroffen hat.
Diese Information wird aber alle drei Sekunden wieder gelöscht.

\begin{lstlisting}[,language=Java]
    function draw() {
        // every second, the countdown gets reduced by 1
        if (frameCount % 60 == 0 && damagedByTimer > 0 && myPlayer.damagedBy != null) {
            damagedByTimer--;
          }
      
        // if the countdown has reached 0, the information gets deleted and the countdown restarts
        if (damagedByTimer == 0) {
            damagedByTimer = 3;
            myPlayer.damagedBy = null;
        }
    }
   
\end{lstlisting}


Wenn ich nun sterbe, und die Information, dass mich jemand getroffen hat in meinem Player-Objekt gespeichert ist, bekommt dieser einen Kill.



\subsubsection{Erstellung der Spielumgebung} \label{impl:Spielumgebung}
Um sich auch auf dem Bild, das der User gezeichnet hat, bewegen zu können, müssen einige Schritte durchgeführt werden. Das Bild kann abfotografiert werden, und mittels Objekterkennung wird daraus ein Array mit Bilddaten erstellt, 
aus dem dann die Spielumgebung kreiert wird. Wie genau dieser Array zustande kommt, wird in Kapitel \ref{maai:udbifdsbd:head} beschrieben.
\\
\begin{lstlisting}[caption=Vereinfachte Darstellung eines Bilddaten-Arrays,language=Java,label=lst:impl:bilddaten]
    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [255, 255, 255, 0], [252, 252, 252, 0], [251, 251, 251, 0],
    [248, 248, 248, 0], [249, 249, 249, 0], [247, 247, 247, 0],
    [255, 255, 255, 0], [240, 240, 240, 0], [250, 250, 250, 0],
    [174, 174, 174, 0], [255, 255, 255, 0], [173, 173, 173, 0],
    [226, 226, 226, 0], [255, 255, 255, 0], [253, 253, 253, 0],
    [163, 163, 163, 0], [254, 254, 254, 0], [255, 255, 255, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
\end{lstlisting}


Je genauer dieser Array ist, desto genauer werden auch die Hitboxen der Spielumgebung, denn die gezeichneten Formen werden mit Rechteck-Hitboxen nachgestellt.
Eine Hitbox ist ein Bereich, der für die Berechnung für Kollision benutzt wird.
Hat ein Eintrag des Arrays an Stelle vier mehr als 0 als Wert, wird dort ein Pixel erstellt. Das liegt daran, dass an der vierten Stelle eines solchen Eintrags die Deckkraft der Bildstelle angegeben wird. Das bedeutet, der User hat dort etwas gezeichnet.
Natürlich muss der Sprite-Pixel noch einen richtigen X- und Y-Wert bekommen. Diese Koordinate muss auch mit dem Punkt des Bildes übereinstimmen, an den der Sprite als Hitbox agieren soll.
Aus Perfomance-Gründen (es wird durchgehend auf Kollidierung zwischen Player und Spielumgebung geprüft) werden die Sprite-Pixel entlang der X-Achse noch zusammengefasst.
Wurden alle Sprite-Pixel ausfindig gemacht, mit richtigen Koordinaten versehen und entlang der horizontalen Achse zusammengefasst, werden alle einer p5-Group-Variable hinzugefügt.
Das macht das Überprüfen auf Kollision einfach. \\
Die nächsten drei Bilder sollen den Ablauf bildlich darstellen.

Zuerst das originale, vom User gezeichnete Bild.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing.PNG}
    \caption{Originale Zeichnung}
\end{figure}

Aus diesem Bild kann ein Array aus Bilddaten erstellt werden. Wenn aber einfach mit diesem Array
die Pixel für die Spielumgebung erstellt, sind diese noch viel zu klein und an der falschen Position.
\\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing2.PNG}
    \caption{Bilddaten-Array bildich dargestellt}
\end{figure}

Um die richtigen Koordinaten für die Sprite-Pixel zu bestimmen, werden noch einige andere Faktoren miteinbezogen und daraus die richtige Position der Pixel am Bildschirm ermittelt.
Außerdem werden sie entlang der X-Achse kombiniert.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{pics/simpleDrawing3.PNG}
    \caption{Spielumgebung}
\end{figure}

Die Sichtbarkeit dieser Sprites wird entfernt. Es soll so wirken, also würde sich der User auf dem, was er gerade gezeichnet hat, bewegen können.
Im Folgenden wird der Algorithmus zum Aufbereiten der Spielumgebung vereinfacht dargestellt.
\begin{lstlisting}[,language=Java,label=lst:impl:createEnv]
    environment = new Group();
    // looping through image data array
    for (let i = 0; i < pixel_clumps.length; i++) {
      sprite_pixels[i] = [];
      for (let j = 0; j < pixel_clumps[0].length; j++) {
        if the value is greater than 0, then something has been drawn there
        if (pixel_clumps[i][j][3] > 0) {
          //if the last value in the array is not undefined, we can merge the sprite-pixels
          if (sprite_pixels[i][j - 1] !== undefined) {
            same_x_counter++;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth * faktorY, pixelWidth * same_x_counter, pixelWidth);
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
            // remove the last value, because it has been replaced by a new sprite, with a greater width
            sprite_pixels[i][j - 1].remove();
            sprite_pixels[i][j - 1] = undefined;
          } else {
            same_x_counter = 1;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth * faktorY, pixelWidth, pixelWidth); 
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
          }
        }
      }
    }
\end{lstlisting}

\subsubsection{Item-Spawns} \label{impl:itemSpawnF}
Alle 10 Sekunden wird ein Item erstellt.
Es wird an oberster Stelle des Bildschirms posiitoniert (y-Koordiante = 0); die x-Position dieses Items wird dann zufällig ausgewählt.
Wichtig dabei ist jedoch, dass das Items auf keiner Position spawnen darf, bei der es einfach oben auftaucht und dann aus dem Bildschirm fällt.
Wie diese x-Koordiaten berechnet werden, wird in Kapitel \ref{impl:xCoordinates} genau beschrieben.
Damit die Items voneinander unterschieden werden können, wird jede Art von Item farblich gekennzeichnet:

\begin{compactitem}
    \item Rot: Bomb
    \item Blau: Black-Hole
    \item Gelb: Piano
    \item Orange: Mine
    \item Grün: Size-Reduction
\end{compactitem}

Den Input, wann ein Item erstellt wird, (muss bei jedem User der gerade spielt gleich sein) liefert der Server. Genauere Details wie der Server von des Web-Games funktioniert, wird in Kapitel \ref{impl:itemSpawnB} beschrieben.
\\

\begin{lstlisting}[caption=Erstellen eines Items,language=Java,label=lst:impl:createItem]
funciton createItem(data) {
    // number between 1-5 from the server to create a random item
    let num = data.num;
    // random x-Coordinate from the server
    let x = data.x
    // this equation gets you the highest point of the map
    let y = (windowHeight - ImageHeight) / 2;
    // if x = -1, something on the server-side went wrong
    if (x != -1) {
        // itemSize is a global variable
        switch (num) {
            case 1:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "bomb";
                break;
            case 2:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "black_hole";
                break;
            case 3:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "piano";
                break;
            case 4:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "mine";
                break;
            case 5:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "small";
                break;
        }
        i.dropped = false;
        items.push(i);
    }
\end{lstlisting}

Nachdem nun das Item erstellt wurde, benötigt dieses natürlich auch so wie zum Beispiel die Projektile oder der Player eine eigene Physik-Methode. Diese wird, so wie die anderen Physik-Methoden auch, in der Draw-Methode aufgerufen.
Die Methode funktioniert so, dass das Item so lange fällt, bis es irgenwo auf der Spielumgebung landet. Jeder Player kann jeder Zeit das Item berühren und somit eine neue Fähigkeit bekommen.

\begin{lstlisting}[caption=Item-Physik,language=Java,label=lst:impl:itemPhy]
    function itemPickUp() {
        if (items.length > 0) {
            items.forEach(item => {
                // if the item collides with the environment, the dropped-attribute becomes true
                if(item.collide(environment)) {
                    item.dropped = true;
                }
                // if the item has not landed anywhere, let it fall 
                if(!item.dropped) {
                    item.velocity.y -= GRAVITY;
                }
    
                // if I collide with the item, I get a new ability depending on the type of the item and the item gets deleted
                if (item.overlap(myPlayer.sprite)) {
                    myPlayer.item[item.type] = new Item(item.type);
                    deleteItem(item);
                }
        }
    }
    \end{lstlisting}

\textbf{Bestimmung von gültigen X-Koordinaten} \label{impl:xCoordinates}
\\
Mit gültiger X-Koordinaten sind jene X-Koordinaten gemeint, bei denen ein Sprite erstellt werden kann, und dieser dann irgendwo auf der Spielumgebung landet und nicht sofort aus dem Bildschirm fliegt.
Bei dem Algorithmus wird zuerst überprüft, auf welchen Stellen Sprite-Pixel (Pixel aus denen die Spielumgebung besteht) vorhanden sind. Von diesen kann schon der Mittelpunkt als gültige X-Koordiate genommen werden, solange dieser Pixel eine gewisse Breite aufweist.
Damit bei einem sehr breiten Pixel nicht nur eine einzige X-Koordinate ausgewählt wird, wird schrittweise überprüft, ob noch Stellen vor oder hinter dem Mittelpunkt des Sprites in Frage kommen.
Dazu wird dieser Sprite-Pixel nach vorne und nach hinten abgetastet, ob noch genügend Platz da ist, ein Item dort landen zu lassen.
Es können höchstens halb so viele X-Koordiaten pro Sprite-Pixel ausgewählt werden, wie der Pixel (in Pixel-Width gemessen) breit ist.
Die Funktion wird im Setup von ScribbleFight aufgerufen.

\begin{lstlisting}[caption=Bestimmung gültiger X-Koordinaten,language=Java,label=lst:impl:xCoords]
    function getXCoordinates() {
        let sprite;
        // looping through the sprite_pixel array
        for (let i = 0; i < sprite_pixels.length; i++) {
            for (let j = 0; j < sprite_pixels[i].length; j++) {
                sprite = sprite_pixels[i][j];
                // if the sprite variable is not undefined, it means a sprite exists there
                // the sprite hast to be a width of at least 4 times the normal pixel width
                if (sprite !== undefined && sprite.width >= pixelWidth * 4) {
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the right of the center)
                    for (let index = 0; index < sprite.width / 2; index += pixelWidth * 2) {
                        if (sprite.position.x + index < sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index;
                            xCoordinates.push(x);
                        }
                    }
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the left of the center)
                    for (let index = sprite.width; index > sprite.width / 2; index -= pixelWidth * 2) {
                        if (sprite.position.x + index > sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index - sprite.width;
                            xCoordinates.push(x);
                        }
                    }
                    // doing this eliminates duplicates
                    xCoordinates = Array.from(new Set(xCoordinates));
                }
            }
            return xCoordinates;
        }
    }
\end{lstlisting}

\textbf{Progressbar} \label{impl:progressbar} \\
Um dem Spieler Feedback zu geben, wie oft er getroffen wurde, wird eine Progressbar am oberen Rand des Bildschirms eingefügt. Je öfter man getroffen wurde, desto mehr füllt sich diese.
Wenn die Progressbar komplett aufgefüllt ist, wird der nächste Treffer eines Projektils den Spieler ein Leben kosten.
Umgesetzt wurde dieses Feature, indem der derzeitigen Knockback des Spieler (ein Wert dafür, wie oft er oder sie schon getroffen wurde) auf den Bereich zwischen 0 bis zur Hintergrundsbildbreite gemapped wird. Dazu wurde die von p5.js vordefinierte Funktion \texttt{map} verwendet.
Als Parameter nimmt diese Funktion:
\begin{compactitem}
    \item Den umzuwandelnden Wert
    \item Start-Wert des ersten Bereichs
    \item End-Wert des ersten Bereichs
    \item Start-Wert des zweiten Bereichs
    \item End-Wert des zweiten Bereichs
\end{compactitem}
\begin{lstlisting}[language=Java, caption=Progressbar,label=lst:impl:progressbar]
//gets called in setup function
function createUI() {
    // position the progressbar at the top of the background-image
    // at the start, the width is of the progessbar is 0
    progressBar = createSprite(windowWidth/2 ,(windowHeight-ImageHeight) / 2,0, width);
    progressBar.position.x += progressBar.width / 2;
    progressBar.position.y += progressBar.height / 2;
    progressBar.shapeColor = color(255,0,0);
}
// gets called whenever my player is hit
function updateUI() {
  let progress;
  progress = map(myPlayer.knockback,1,MAX_KNOCKBACK,0,newImageWidth);
  progressBar.width = progress;
}
\end{lstlisting}

\subsection{Server [R]}
Der Server des Spiels ist ein Web-Server, der mit Node.js und express.js umgesetzt wurde.
Dieser hostet statische Files, auf denen sich der Code für das Frontend befindet (HTML Files, p5.js library, etc).
Viele Teile dieses Codes werden im vorherigen Kapitel detailliert erklärt.
Durch SocketIO können multiple Clients eine Verbindung mit dem Server aufbauen.
So wird es ermöglicht, dass unterschiedliche Clients gemeinsam spielen können.

\subsubsection{Erstellen des Servers}
Ein Node.js Server ist einfach zu erstellen. Zwei Voraussetzungen müssen vorhanden sein:

\begin{compactitem}
    \item Eine funktionierende Node.js-Version
    \item JavaScript Grundlagen
\end{compactitem}

Ist dies gegeben, kann ein neuen Ordner erstellt, und in diesem dann der Befehl \texttt{npm init} ausgeführt werden.
Dort wird dann ein package.json File für das Node-Projekt erstellt. Nähere Infos zu diesem File kann in Kapitel \ref{NPM} nachgelesen werden.
Danach kann entweder durch eine Entwicklungsumgebung ein neues JavaScript File erstellt, oder im Terminal der Befehl \texttt{touch server.js} eingegeben werden.
In dem Backend von ScribbleFight werden express.js und SocketIO benutzt, deshalb müssen die Befehle \texttt{npm install express --save} für express.js, und
\texttt{npm install socket.io} für SocketIO im Terminal ausgeführt werden. Dies installiert die Module und fügt die Abhängigkeiten zu dem package.json-File hinzu.

Wurde all das berücksichtigt, kann die Logik des server.js-Files umgesetzt werden. Zuerst wird eine Instanz von express.js erstellt.
Danach wird ein HTTP-Server-Objekt und eine SocketIO Instanz angelegt, die das HTTP-Server-Objekt als Paramter nimmt. Zusätzlich wird noch Cross-Origin Resource Sharing freigegeben. 
Dies ist ein Mechanismus, der festlegt, welche Quellen aus dem Internet Resourcen von dem Server laden darf. \cite{cors}
Der Code sieht also so aus:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    var express = require("express");
    var app = express();
    var http = require("http").createServer(app);
    var io = require("socket.io")(http, {
        cors: {
            origin: '*',
        }
    });
\end{lstlisting}

Bei dem Web-Game muss, wie vorher schon erwähnt, das Frontend in Form von statischen Files gehostet werden.
Für dieses Problem wurde das Paths-Module von Node.js verwendet. Dieses stellt Funktionen für das Arbeiten mit File-und Directory-Pfaden zur Verfügung. Darauf zugegriffen werden wird mit:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    const path = require('path');
\end{lstlisting}

Nun können die Files mit \\

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    // path.join is used to get the right path 
    app.use(express.static(path.join(__dirname, '/../p5_frontend/src')));
\end{lstlisting}

gehostet werden (Diese befinden sich in dem Folder <src>).

Als letzten Schritt wird noch der Port bei dem HTTP-Server-Objekt angegeben, im Fall von unserem Server ist dieser 3000.
\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    // Server is listening on port 3000
    http.listen(3000);
\end{lstlisting}

Ist das alles abgeschlossen, wird nun die SocketIO Logik umgesetzt.

\subsubsection{SocketIO Logik}
Der funktionierende Web-Server soll SocketIO-Verbindungen, die vom Browser kommen, annehmen können.
Mit der SocketIO Instanz, die im letzten Abschnitt erstellt worden ist, kann dieses Problem gelöst werden:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    io.sockets.on('connection', newConnection);

    function newConnection(socket) {
        // LOGIC COMES HERE
    }
\end{lstlisting}

Findet nun eine Verbindung zu dem Server von einem Client statt, wird die Methode <newConnection(socket)> aufgerufen.
Der Parameter der Methode ist eine Socket-Instanz, die sehr viele Informationen und Funktionalitäten der gerade bestehenden Verbindung enthält.
Wie der Client eine Verbindung zu diesem Server aufbauen kann, ist von Programmiersprache zu Programmiersprache unterschiedlich. Im Frontend von ScribbleFight wird JavaScript benutzt.

\textbf{SocketIO im Frontend}

Um im Frontend eine SocketIO-Verbindung aufzubauen, wird in dem index.html File die SocketIO Library verlinkt:
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // link SocketIO in index.html
    <script src="https://cdn.socket.io/4.1.2/socket.io.min.js"></script>
\end{lstlisting}

Jetzt kann eine neue Socket-Instanz erstellt werden, mit deren Hilfe der Client Events empfangen, aber auch aussenden kann.
Da der Server von ScribbleFight nicht mehr lokal läuft, sondern auf einem Kubernetes-Cluster, wird hierbei noch ein Pfad definiert, um eine korrekte Instanz zu erstellen.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    var socket = io({
        path: "/t.rafetseder/scribble-fight/socket.io"
      }); 
\end{lstlisting}

Der Befehl \texttt{io()} alleine würde die Pfad-Parameter (/t.rafetseder/scribble-fight/socket.io) der derzeiten Domaine einfach ignorieren und die Verbindung könnte nicht hergestellt werden.
\\
Nun können mit dem Befehl
\texttt{socket.on('event',function)} Events empfangen, und mit \texttt{socket.emit('event')} Events ausgelöst werden.

\textbf{SocketIO Events} \\
Nachdem nun eine aufrechte Verbindunge hergestellt werden konnte, gibt es 10 Events, die auftreten können:
\begin{compactitem}
    \item Ein neuer Spieler soll erstellt werden
    \item Abruf von schon bestehenden Spielern
    \item Die Position des eigenen Sprites soll aktualisiert werden
    \item Die Richtung, in die der Sprite des Spielers schaut, soll aktualisiert werden
    \item Ein Item wurde aufgehoben, also soll es bei jedem entfernt werden
    \item Jemand hat eine Attacke ausgeführt, also soll bei jedem ein Projektil erstellt werden
    \item Jemand hat einen Kill erzielt
    \item Ein Spieler wurde von einem Projektil getroffen, das heißt das Projektil, das getroffen hat, muss bei jedem entfernt werden
    \item Jemand ist gestorben
    \item Es soll ein neues Item erstellt werden (Event wird alle 10 Sekunden ausgelöst)
\end{compactitem}

Diese Events werden im Folgenden genau erklärt.

\textbf{Erstellen eines neuen Spielers und Abrufen von vorhandenen Spielern} \\
Führt der Spieler das Frontend aus, stellt dieses sofort eine Verbindung mit dem Server her. Um nun schon vorhandene Spieler, die gerade auch verbunden sind zu erhalten, wird ein Event <getPlayers> ausgelöst.
Danach muss dem Server noch mitgeteilt werden, dass der Spieler nun selbst auch eine spielbare Figur erhalten möchte. Dies wird mit dem <newPlayer>-Event bewerkstelligt.
Wird nun das Event <newPlayer> vom Server ausgelöst, wird ein neues Player-Objekt dem Player-Array des Frontends hinzugefügt. Der Konstruktor von diesem Player-Objekt benötigt nur einen Sprite, der auch neu erstellt wird.
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // listen to an event from the server
    socket.on('newPlayer',createNewPlayer);
    // get existing players
    socket.emit('getPlayers');
    // create my own player
    socket.emit('newPlayer');

    function createNewPlayer(data) {
        // new player gets added an new sprite is created in the middle of the map
        players[data.id] = new Player(createSprite(ImageWidth / 2,ImageHeight / 2, player_width, player_height));
    }
\end{lstlisting}

Grundsätzlich speichert der Server alle Player-Objekte in einem Map-Objekt ab.
Für die ID für jedes dieser Player-Objekte wird einfach die ID der Socket-Verbindung verwendet. Will ein Client nun alle schon vorhandenen Spieler, wird die Map (falls Spieler vorhanden) durchlaufen, und die ID von jedem der Spieler an den anfragenden Client geschickt.
Dieser erstellt dann einen, beziehungsweise mehrere neue Player mit der dazugehörigen ID.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('getPlayers',sendPlayers);

    // the object players is the map that has the player-objects saved
    function sendPlayers() {
        if (players.size > 0) {
            players.forEach((values, keys) => {
                let data = {
                    id: values.id,
                }
                socket.emit('newPlayer', data);
            })
        }
    }
\end{lstlisting}

Nachdem nun der Server alle schon vorhandenen Spieler dem Client mitgeteilt hat, muss noch ein neuer Spieler für diesen Client erstellt werden.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('newPlayer',createPlayer);  

    function createPlayer() {
        players.set(socket.id, new Player(socket.id));
        let data = {
            id: socket.id,
        }
        // im using io.emit() so it sends to everyone, including the client that triggered the event
        io.emit('newPlayer', data);
    }
\end{lstlisting}

Der Client erstellt nun genau gleich wie bei dem <getPlayers>-Event den Spieler.

\textbf{Update Position and Update Direction}

Die Postion des Sprites von jedem Spieler soll in jedem Draw-Zyklus aktualisiert werden. Die Orientierung des Sprites soll nur dann aktualisiert werden, wenn der Spieler die Richtung seines Sprites wechselt. (Beschrieben in Kapitel \ref{directionChange})
Leider ergibt sich beim Aktualisieren von Positionen von Sprites ein Problem. Die Koordinaten in p5.js werden in Pixel angegeben. Das bedeutet, verwenden unterschiedliche Clients unterschiedlich große Endgeräte, befinden sich Sprites mit gleichen Koordinaten an unterschiedlichen Stellen.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/pixelDiff.PNG}
    \caption{Pixel-Unterschied}
\end{figure}

Aus diesem Grund können nicht nur die rohen Koordinaten an alle Clients geschickt werden, sie müssen in Relation zu dem Bildschirm des Endgeräts und der Größe der Map, also dem Bild auf dem gerade gespielt wird, gesetzt werden.
(Dies ist nicht nur bei den Spieler-Koordintaten, sondern auch bei z.B. Items der Fall)
Der Code am Ende von jedem Draw-Zyklus sieht also so aus:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    let transferX = (myPlayer.sprite.position.x - (windowWidth - ImageWidth) / 2) * originalBildBreite / neueBildBreite;
    let transferY = (myPlayer.sprite.position.y - (windowHeight - ImageHeight) / 2) * originalBildHoehe / neueBildHoehe;
    relPosData = {
      x: transferX,
      y: transferY
    }
    socket.emit('update', relPosData);
\end{lstlisting}

Im Server werden diese Koordinaten einfach zusammen mit der passenden ID des Players an alle Spieler verteilt:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

socket.on('update',updatePosition)

    function updatePosition(data) {
        let posData = {
            x: data.x,
            y: data.y,
            id: socket.id
        }
        // with socket.broadcast, everyone except the one who triggered the event gets the data
        socket.broadcast.emit('updatePosition', posData);
    }
\end{lstlisting}

Empfängt ein Client die Koordinaten, muss er diese wieder für sein Endgerät richtig umwandeln:


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

socket.on('updatePosition',updatePosition);

    function updatePosition(data) {
        players[data.id].sprite.position.x = 
        data.x * neueBildBreite / originalBildBreite + (windowWidth - neueBildBreite) / 2;

        players[data.id].sprite.position.y = 
        data.y * neueBildHoehe / originalBildHoehe + (windowHeight - neueBildHoehe) / 2;
    }
\end{lstlisting}

Das Aktualisieren der Richtung des Sprites ist hingegen leichter. Dort spielt es keine Rolle, wie groß das Endgerät ist.
Beim Drücken von A oder D auf der Tastatur, wird einfach ein Event ausgelöst, das die Richtung des Sprites bei jedem verbundenen Spieler ändert.


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // A
    if (keyWentDown(65)) {
        socket.emit('updateDirection', 'left');
    }
    // D
    if (keyWentDown(68)) {
        socket.emit('updateDirection', 'right');
    }
\end{lstlisting}

Im Server wird die Information an alle Clients verteilt:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
   socket.on('updateDirection',updateDirection);

   function updateDirection(data) {
    let dataWithId = {
        id: socket.id,
        direction: ""
    }
        if (data == "left") {
            dataWithId.direction = "left";
            socket.broadcast.emit('updateDirection', dataWithId);
        } else if (data == "right") {
            dataWithId.direction = "right";
            socket.broadcast.emit('updateDirection', dataWithId);
        }
}
\end{lstlisting}

Wird vom Client nun das <updateDirection>-Event empfangen, wird einfach die Orientierung des Sprites geändert.

\textbf{Synchronisieren von Projektilen oder Items} \\
Wenn ein Item aufgesammelt wird, soll dieses für die anderen Spieler nicht mehr verfügbar sein. Genauso soll, wenn eine Attacke ausgeführt wird, diese bei allen anderen Spielern auch ausgeführt werden.
Die Logik dazu ist relativ simpel. Jedes Item bekommt beim Erstellen eine eigene unique ID. Sammelt nun irgendein Spieler dieses Item auf, wird an den Server eine Benachrichtigung gesendet, dass jemand dieses Item aufgesammelt hat.
Dieser verteilt diese Information an alle Spieler, und das Item mit der richtigen ID wird bei jedem gelöscht.
Bei den Projektilen ist es ähnlich. Wenn ein Spieler eine Attacke ausführt, wird auch das dem Server mitgeteilt. Der verteilt nun wieder die Information an alle Spieler, und bei jedem wird ein neues Projekil mit der gleichen ID erstellt.
Wenn einer der Spieler eine Kollision zwischen Player-Sprite und einem Projektil feststellt, wird das dem Server mitgeilt und dieser teilt allen anderen Spielern mit, dass das Projektil bei jedem gelöscht werden muss.
Der Server hat einen Array mit Item-Objekten gespeichert. Vereinfacht sieht die Logik so auf der Server-Seite aus:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

    socket.on('deleteItem', deleteItem);
    socket.on('attack', syncAttacks);
    socket.on('deleteAttack', deleteAttack);

    function deleteItem(data) {
        items.forEach(i => {
            if (i == data.id) {
                // remove item from item array
                items.splice(items.indexOf(i), 1);
                socket.broadcast.emit('deleteItem', data);
            }
        });
    }

    // data consist of type of attack and attack ID
    function syncAttacks(data) {
        socket.broadcast.emit('attack', data);
    }

    // data consist of type of attack and attack ID
    function deleteAttack(data) {
        socket.broadcast.emit("deleteAttack", data);
    }

 \end{lstlisting}

Im Frontend werden die bestimmten Events am richtigen Ort ausgelöst.
Zum Beispiel, wenn eine Bombe erstellt wird:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    funciton addBomb() {
        // bomb gets created here
        let data = {
            playerId: socket.id,
            type: "bomb",
            x: bomb.position.x,
            y: bomb.position.y,
        }   
        socket.emit("attack",data);
    }
 \end{lstlisting}


Natürlich befindet sich auch die Logik, um die vom Server ausgelösten Events zu empfangen und darauf zu reagieren, am Client.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('deleteItem', syncItems);
    socket.on('attack', addAttack);
    socket.on('deleteAttack', deleteAttack);

    // remove item from the item array
    function syncItems(data) {
        items[data.index].remove();
        items.splice(items.indexOf(items[data.index]), 1);
    }

    // add a projectile, depending on the type of attack
    function addAttack(data) {
    switch (data.type) {
        case "default": addDefaultAttack(data);
            break;
        case "bomb": addBomb(data);
            break;
        case "blackHole": addBlackHole(data);
            break;
        case "piano": addPiano(data);
            break;
        case "mine": addMine(data);
            break;
        case "small": addSmall(data);
            break;
        }  
    }

    // delete the right projectile, depending on the type and the ID of the projectile
    function deleteAttack(data) {
        
        switch (data.type) {
            case "default":
                projectiles.forEach(p => {
                    if (p.id === data.id) {
                        p.remove();
                    }
                });
                break;
            case "bomb":
                bombs.forEach(b => {
                    if (b.id === data.id) {
                        b.remove();
                    }
                });
                break;
        // ... and so on
        }
    }

 \end{lstlisting}

\textbf{Tode und Kills} \\
Wie der Spieler in ScribbleFight gewinnt, wann er 'stirbt' und wie er Kills sammelt wird auf der Client-Seite in Kapitel \ref{impl:win} beschrieben.
Doch muss der Client auch mit dem Server kommunizieren, damit dieser alle diese Events auch an alle anderen Spieler mitteilen kann.
Stirbt ein Spieler, teilt er dies dem Server mit. Dieser speichert die Information ab und überprüft, ob der Spieler noch weiter mitspielen darf.
Ist er jedoch schon zum dritten Mal gestorben, ist dies nicht mehr der Fall und der Spieler wird aus der Spieler-Map vom Server gelöscht.
Ist ab dem Zeitpunkt nur mehr ein einziger Spieler in dem Map-Objekt gespeichert, hat dieser gewonnen.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    function death(data) {
        players.get(data.deadPlayer).death++;
        if (players.get(data.deadPlayer).death >= 3) {
            // delete the player from player-map
            players.delete(data.deadPlayer);
            let transferData = {
                id: data.deadPlayer
            }
            // send the information that someone died to everyone
            io.emit('death', transferData);
            // disconnect the socket connection
            socket.disconnect();
        }
        // if player-map only has one player left, he has won 
        if (players.size <= 1) {
            socket.broadcast.emit("win");
        }
    }
 \end{lstlisting}

Der Client muss jetzt auf beide Events, also falls er gerade vom Spiel ausgeschieden wurde, oder gerade gewonnen hat, reagieren können.
Bekommt er die Benachrichtigung, dass jemand ausgeschieden wurde, wird überprüft, ob es sich um ihn selbst handelt.
Falls ja, wird die draw-Methode gestoppt, ihm wird mitgeilt, dass er verloren hat und eine kurze Übersicht von seinen Spiel-Statistiken wird angezeigt.
Die Übersicht beinhaltet:
\begin{compactitem}
    \item Den Schaden, den er an alle anderen Spieler ausgeteilt hat
    \item Anzahl an Kills, die erzielt worden sind
    \item Der eigene Knockback, also ein Indikator wie oft der Spieler getroffen worden ist
\end{compactitem}
Falls es sich nicht um ihn handelt, passiert nichts.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('death',someoneDied);

    // data consits of id of dead player
    function someoneDied(data) {
    players[data.id].sprite.remove();
    if (data.id == myPlayer.id) {
        alert("You died!\n
        Your kills: " + myPlayer.kills + "\n" 
        + "Your damage: " + myPlayer.dmgDealt + "\n" 
        + "Your knockback: " + myPlayer.knockback);

        // stop the draw-function
        noLoop();
    }
}
 \end{lstlisting}

Bekommt der Spieler nun aber die Benachrichtigung, dass er gewonnen hat, wird diese Nachricht ausgegeben und auch hier wird wieder eine kurze Übersicht der Spiel-Statistiken gezeigt.
Diesmal aber inklusive den Toden, da sie dieses Mal nicht mit Sicherheit drei sind.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('win',win);
     
    function win() {
        alert("You won!\n
        Your kills: " + myPlayer.kills + "\n" 
        + "Your damage: " + myPlayer.dmgDealt 
        + "\n" + "Your knockback: " + myPlayer.knockback 
        + "\n" + "Your deaths: " + myPlayer.death);
    }
 \end{lstlisting}

Wird im Client bestimmt, dass gerade ein Kill erzielt worden ist, speichert der Server diese Information ab, damit sie abrufbar ist.
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('kill',kill);
    
    // data consists of the id of the player who should get the kill
    function kill(data) {
        // player could leave before getting the kill
        if (players.get(data.damagedBy) != undefined) {
            players.get(data.damagedBy).kill += 1;
    }

 \end{lstlisting}

Es wurde schon fast alles beschrieben, was der Server benötigt, damit das Web-Game funktionert.
Das einzige, was fehlt, ist dass der Server allen Spielern mitteilen muss, wann ein neues Item erscheinen soll.

\textbf{Item-Spawn-Event} \label{impl:itemSpawnB} \\
Items werden in ScribbleFight alle 10 Sekunden gespawned, falls ein Spieler mit dem Server verbunden ist.
Mit der Methode \texttt{setIntervall()} kann ein Intervall definiert werden, in dem eine Funktion ausgeführt werden soll.
Das Intervall wird auf 10 Sekunden gesetzt. Nun wird, solange ein Spieler vorhanden ist, alle 10 Sekunde ein Event ausgelöst, dass allen verbundenen Spielern mitteilt, wo welche Art von Item erstellt werden soll.
Wie die x-Koodinaten berechnet werden, die für die Item-Spawns in Frage kommen, wird in Kapitel \ref{impl:xCoordinates} beschrieben.
Auf der Server-Seite sieht der Code also so aus:
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    setInterval(() => {
        // if players are connected with the server
        if (players.size > 0) {
            // get one of the available spawn points for items
            let x = getItemSpawnPoint();
            let data = {
                id: randomId(),
                x: x,
                num: getRandomInt(5)
            }
            // too many items on the field
            if (x != -1) {
                items.push(data.id);
            }
            // sending the event to every connected player
            io.emit('spawnItem', data);
        }
    }, 10000);

 \end{lstlisting}

Der Client muss jetzt beim Empfangen dieses Events ein Item am richtigen Ort erstellen.
Wie Items am Client erstellt werden, kann in Kapitel \ref{impl:itemSpawnF} nachgelesen werden.\\
Vereinfacht sieht der Code am Client also so aus:


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('spawnItem',createItem);

    // data consits of item-ID, type of item and position of item
    funciton createItem(data) {
        // item gets created here
    }
 \end{lstlisting}

Somit wurde der komplette Umfang des ScribbleFight-Web-Servers beschrieben. Dieser läuft allerdings nicht mehr lokal, sondern auf einem Kubernetes-Cluster, der von der HTL Leonding bereitgestellt wurde.
Wie der Server deployed werden konnte, wird in dem nächsten Kapitel beschrieben.


\section{Deployment [R]} \label{impl:Deployment}
\setauthor{Rafetseder Tobias}
Die Grundlage, um etwas auf einen Kubernetes-Cluster deployen zu können, ist ein Docker-Image. Näheres zu der Docker-Technologie wird in Kapitel \ref{tech:docker} beschrieben.
\subsection{Docker-Image [R]}
Da es sich bei dem Server, der für das Web-Spiel notwendig ist, um einen Web-Server, der statische Files hostet, handelt, und keine Datenbank nötig ist, ist das Docker-File relativ simpel.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.85]{pics/dockerfile_scribble.PNG}
    \caption{ScribbleFight Dockerfile}
\end{figure}
Die Zeilen Code werden im Folgenden genauer erläutert. \\
\begin{lstlisting}
    FROM node:16
\end{lstlisting}
Da Docker-Images von anderen Docker-Images erben können, wird nicht ein eigenes Base-Image verwendet, sondern das offizielle Node.js Image, das schon die Tools und Packages hat, die benötigt werden, um eine Node.js-Applikation auszuführen.
\\
\begin{lstlisting}
    WORKDIR /usr/src/app
\end{lstlisting}
Es wird ein neues Verzeichnis erstellt, von wo aus gearbeitet wird.
In diesem Verzeichnis werden alle nachfolgenden Befehle ausgeführt. Der Vorteil davon ist, dass keine absoluten File-Pfade benutzt werden müssen, sondern Pfade, relativ zu diesem Verzeichnis benutzt werden können. \\


\begin{lstlisting}
    COPY ./p5_backend/package*.json ./p5_backend/
\end{lstlisting}
Bevor \texttt{npm install} ausgeführt werden kann, muss das package.json File und package-lock.json File auf das Image kopiert werden.
Dazu wird \texttt{COPY} benutzt. Dieser Befehl nimmt zwei Parameter: Source und Destination. Es werden package.json und package-lock.json in einen neuen Ordner des vorherig erstellen Arbeits-Verzeichnis kopiert. \\

\begin{lstlisting}
    WORKDIR /usr/src/app/p5_backend
    RUN npm install
\end{lstlisting}
Es wird das Verzeichnis, in das das package.json-und package-lock.json File kopiert worden sind, als Arbeits-Verzeichnis definiert.
Da dort diese Files vorhanden sind, kann \texttt{npm install} ausgeführt werden und alle nötigen Abhängigkeiten werden heruntegeladen. \\

\begin{lstlisting}
    WORKDIR /usr/src/app
    COPY ./p5_backend ./p5_backend
    COPY ./p5_frontend ./p5_frontend
\end{lstlisting}

Es wird wieder das ursprüngliche Verzeichnis als Arbeits-Verzeichnis definiert. Dorthin werden die Files, die der Server zum Funktionieren braucht und auch die Files für das Frontend, die der Server hostet, kopiert. \\

\begin{lstlisting}
    EXPOSE 3000
    CMD [ "node", "./p5_backend/server.js" ]
\end{lstlisting}

Zuletzt wird nur mehr der Port, den der ScribbleFight-Server akzeptiert, nach aussen freigegeben, und mit dem Befehl \texttt{CMD} der Server gestartet. \cite{build_image}

\subsection{Leo-Cloud [R]}
Die Leo-Cloud ist eine Cloud-Computing-Umgebung der HTL Leonding.
Da ein funktionierendes Image des Web-Servers vorhanden ist, kann an dem Deployment an die Leo-Cloud gearbeitet werden.

Zuerst muss das Image, das für das Deployment verwendet werden soll, in das Docker-Registry der HTL Leonding geladen werden.
Dazu kann der Befehl \texttt{docker login registry.cloud.htl-leonding.ac.at} benutzt werden, um sich mit den eigenen Anmeldedaten dort einzuloggen.
Danach wird das Image einfach mit dem Befehl \texttt{docker push <registry-name>} hochgeladen.

Um das Deployment umzusetzten, werden drei YAML-Files benötigt.
YAML ist eine Daten-Serialisierungs-Sprache, die benutzt wird, um Konfigurations-Files zu schreiben.

Diese drei Files sind:
\begin{compactitem}
    \item Deployment-File
    \item Service-File
    \item Ingress-File
\end{compactitem}

In dem Deployment-File kann die Konfiguration zum eigentlichen Deployment festgelegt werden, zum Beispiel welches Image verwendet werden soll,
welche Anzahl an Pods (Linux-Containern) verwendet werden soll, oder welcher Port benutzt werden soll.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.85]{pics/deployment.PNG}
    \caption{ScribbleFight Deployment.yaml}
\end{figure}

Auf einem Kubernetes-Cluster laufen viele Pods. Ein Service erlaubt Usern, auf eine Gruppe von Pods zuzugreifen.
Dazu wird die IP-Adresse eines Pods zu einem statischen Service-Name abstrahiert, sodass externe Requests zu verschiedenen Pods geleitet werden können.
\\
Das Weiterleiten von Requests zu dem erwünschten Pod basiert auf der \texttt{selector}-spec am Service, der mit dem Metadaten-Label des Pods zusammenpassen muss.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/service.PNG}
    \caption{ScribbleFight Service.yaml}
\end{figure}

Zusätzlich muss noch konfiguriert werden, wie Services in einem Cluster via IP-Adresse oder URL erreicht werden können.
Dazu werden Ingress-Files verwendet. Ein Ingress ist eine Ansammlung von Regeln, die einkommende Verbindungen erlauben, Cluster-Services zu erreichen.
Das Ingress-Spec-Field stellt einen Service-Namen und Service-Port bereit, der gemeinsam mit der URL-Route von dem Service exposed wird.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.85]{pics/ingress.PNG}
    \caption{ScribbleFight Ingress.yaml}
\end{figure}



% Ben dein teil kommt hier herein


\section{Lobby [W]}
\setauthor{Weinzierl Ben}
\subsection{Aufbau}
Bei dieser Arbeit gab es drei Teile. Das Spiel, die Map-Erkennung und die Lobby. Diese wurden im Frontend alle mit HTML, CSS und JavaScript umgesetzt. 
Für das Backend haben die Lobby und das Spiel jeweils einen Node.js Server verwendet. Die Bilderkennung hat dafür einen Python-Flask Server verwendet. Die Lobby, welche als Mittelteil fungierte, hat mittels Socket.io die Kommunikation zwischen den Teilen dargestellt. 
Um die Spieler und Spielerinnen miteinander spielen zu lassen wird ein 4-stelliger Code, die Game-ID generiert. Dieser kann dann an die Mitspieler und Mitspielerinnen geschickt werden. In der Lobby wird auch ein QR-Code dargestellt welcher auf die Bilderkennung verlinkt. 
Wird dort (auf dem Python Server) ein Bild hochgeladen wird dies an die Lobby weitergeleitet. Sind alle Spieler und Spielerinnen fertig mit dem Upload, wird das Voting gestartet. Steht ein Gewinner fest (bei gleichstand wird zufällig gewählt), wird auf das Spiel verlinkt. Dabei wird das Gewinnerbild mitgeschickt und die Spieler und Spielerinnen können anfangen, sich zu bekämpfen.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{pics/architektur.png}
    \caption{Aufbau von ScribbleFight}
\end{figure}  

\subsection{Lobby Sockets}
Wird die Seite aufgerufen, wird dem User erstmal eine ID zugewiesen. ``guid()'' ist eine Funktion welche eine zufällige 4-stellige Zahl erszeugt. 
Beim Client wird die ID noch im Localstorage gespeichert.
\begin{lstlisting}[language=html,caption=Socket Connection]
    
    Server:
    io.on('connection', socket => {

        const clientId = guid();
        socket.id.clientId = clientId;
        socket.clientId = clientId;
        const payLoad = {
            "clientId": clientId
        }
        socket.emit("connecting", payLoad)
    });

    Client:
    socket.on('connecting', response => {
        clientId = response.clientId;
        localStorage.setItem("localClient", clientId)
        console.log("Client id succesfully set" + clientId);
    });


\end{lstlisting}

Der User oder die Userin hat dann 2 Möglichkeiten. Es wird entweder ein Spiel ``created'' oder ``gejoined''.
Wird ersteres ausgewählt bekommt der Server eine Nachricht, dass dieser Spieler ein Spiel erstellen möchte. 
Dabei werden einige JSON Variablen initialisiert, welche später gebraucht werden. Die Game-ID wird, wie die Client-ID, 
mit der Funktion guid() initialisatiert. Danach wird der User, benachrichtigt, dass sein Spiel erstellt wurde. Im Frontend wird dann der Gamecode ausgegeben, und
damit der User, der die Lobby erstellt hat, dieser auch beitritt, wird noch die ``join'' Funktion aufgerufen. 
\begin{lstlisting}[language=html,caption=Create Game]
    
    Server:
    socket.on('create', message => {
        const clientId = message.clientId;
        const gameId = guid();
        games[gameId] = {
            "id": gameId,
            "clients": [],
        }
        picGames[gameId] = {
            "id": gameId,
            "clients": []
        }
        voteGames[gameId] = {
            "id": gameId,
            "clients": [],
            "votes": []
        }
        playerVotes[gameId] = {
            "id": gameId,
            "clients": [],
        }

        const payLoad = {
            "method": "create",
            "game": games[gameId]
        }
        socket.emit("create", payLoad)
    });


    Client:
    socket.on('create', response => {
        console.log("Game succesfully created with " + response.game.id);
        let gamecode = document.getElementById("gamecode");
        gameId = response.game.id;
        gamecode.innerHTML = "Gamecode: " + gameId;
        const message = {
            "method": "join",
            "clientId": clientId,
            "gameId": gameId
        }
        socket.emit('join', message)
    })


\end{lstlisting}


Das Beitreten beginnt damit, dass überprüft wird ob der mitgeschickte Gamecode existiert.
Tut er das nicht, oder sind schon zu viele Spieler in der Lobby, wird ein Error ausgegeben. Ist alles gut gegangen, wird den im ``create'' initialisierten JSON-Arrays die ClientId hinzugefügt und der User tritt dem Socket-Raum bei. Danach wird der User, welcher gerade gejoined ist, mit socket.emit,
benachrichtigt. Alle anderen Spieler dieser Lobby werden dann noch mit io.in benachrichtigt,
dass ein neuer User gejoined ist. Auf der Clientseite wird im ``newClient'' der QR-Code initialisiert. 
Im ``join'' des Frontends werden alle gejointen Spieler und Spielerinnen ausgegeben. 
\begin{lstlisting}[language=html,caption=Join Game]
    
    Server:
    socket.on('join', message => {
        if (games[message.gameId]) {
            const clientId = message.clientId;
            const gameId = message.gameId;
            const game = games[gameId];
            const clients = io.sockets.adapter.rooms.get(gameId);

            if (game.clients.length >= 8) {
                console.log("Maximal 8 Spieleer")
                const payLoad = {
                    "method": "error",
                    "message": "Too many players in lobby"
                }
                io.to(gameId).emit(payLoad)
            } else {
                games[gameId].clients.push({
                    "clientId": clientId
                })
                picGames[gameId].clients.push({
                    "clientId": clientId
                })
                voteGames[gameId].clients.push({
                    "clientId": clientId,
                })
                voteGames[gameId].votes.push({
                    "amount": 0,
                })
                playerVotes[gameId].clients.push({
                    "clientId": clientId,
                })
                const payLoadNew = {
                    "method": "newClient",
                    "newClient": clientId,
                    "gameId": games[gameId].id
                }
                socket.emit('newClient', payLoadNew)
                const payLoad = {
                    "method": "join",
                    "game": games[gameId]
                }

                let gameString = "" + gameId
                console.log(gameString);
                socket.join(gameString, () => console.log("RoomID: " + socket.rooms))
                io.in(gameString).emit('join', payLoad)
            }
        } else {
            console.log("error")
            const payLoad = {
                "method": "error",
                "message": "Gamecode does not exist!"
            }
            let gameString = "" + gameId
                console.log(gameString);
                socket.join(gameString, () => console.log("RoomID: " + socket.rooms))
                io.in(gameString).emit('join', payLoad)
        }
    })


    Client:
    socket.on('newClient', response => {
        var localClient = response.newClient;
        const qrLink = document.getElementById("qrLink");
        qrLink.href += response.gameId + "/" + response.newClient
        initQr(response.gameId, response.newClient)
    })

    socket.on('join', response => {
        const game = response.game;
        let gamecode = document.getElementById("gamecode");
        var gameId = response.game.id;
        gamecode.innerHTML = "Gamecode: " + gameId;
        var i = 0;
        const playerlist = document.getElementById('playerlist');
        playerlist.innerHTML = "<br>";
        game.clients.forEach(c => {
            playerlist.innerHTML +=
            "<div><p>Player " + (i + 1) + "</p></div>"
            i++
        });
    })
\end{lstlisting}

Hat ein User seine gezeichnete Map hochgeladen wird der Server benachrichtigt (\ref*{PythonSocket}). 
Sobald der Server die Nachricht bekommen hat, wird der User der das Bild hochgeladen hat, als ready eingestuft. Dies wird durch das herauslöschen aus dem picGame.clients-Array gemacht.
Danach wird das Bild unter der richtigen clientId abgespeichert und es wird allen Usern der Lobby mitgeteilt, dass ein Bild hochgeladen wurde. 
Dort wird überprüft ob schon alle User ihre Bilder hochgeladen haben. Ist das der Fall erscheint ein Button welcher das Voting starten lässt.
\begin{lstlisting}[language=html,caption=picUploaded]
    
    Server:
    socket.on('picUploaded', message => {
        const gameId = message.gameId;
        const game = games[gameId];
        const img = message.img;
        const map = message.map;
        const clientId = message.clientId;
        var i = 0;
        picGames[message.gameId].clients.forEach(c => {
            if (picGames[message.gameId].clients[i].clientId == message.clientId) {
                console.log("yesss")
                picGames[message.gameId].clients.splice(i, 1)
            }
            i++;
        })
        i = 0;
        game.clients.forEach(c => {
            if (c.clientId == message.clientId) {
                games[gameId].clients[i].img = img;
                games[gameId].clients[i].map = map;
            } else {
                console.log("noooo")
            }
            i++;
        })

        const payLoad = {
            "method": "picUploaded",
            "game": games[gameId],
            "picGame": picGames[gameId],
        }

        let gameString = "" + gameId
        io.in(gameString).emit('picUploaded', payLoad)
    })



    Client:
    socket.on('picUploaded', response => {
        var picGame = response.picGame
        var game = response.game
        var img = response.img;
        var missingPlayers = document.getElementById("missingPlayers");
        var info = document.getElementById("info");
        info.innerHTML = game.id
        var x = game.clients.length;
        i = 0;
        var miss = [];
        missingPlayers.innerHTML = "Still Players missing!"
        picGame.clients.forEach(c => {
            if(picGame.clients[i].clientId == game.clients[i].clientId){
                miss[i] = true;
            } else {
                miss[i] = false;
            }
            i++;
        })
        // Wenn alle User was hochgeladen haben soll Button erscheinen (i=0)
        var buttonBox = document.getElementById("buttonBox");
        if (i == 0) {
            missingPlayers.innerHTML = "Ready to start the voting!"
            buttonBox.innerHTML =
            '<button id="startVoting" onClick="startVoting()">Start Voting</button>'
        } else {
            buttonBox.innerHTML = ''
        }

    })
    
\end{lstlisting}

Wurde das Voting gestartet werden alle User benachrichtigt.
Daraufhin wird bei allen Usern der Lobby im Frontend ein Balkendiagramm initialisatiert. Die Parameter dieses Diagramms wurden in \ref*{ChartJs} erläutert. 
In das Diagramm werden dann noch die Player eingefügt und es wird jeweils das gezeichnete Bild und ein Votingbutton dargestellt. 
\begin{lstlisting}[language=html,caption=Start Voting]
    
    Server:
    socket.on('startVoting, message => {
        const game = message.game;
        const myClient = socket.clientId
        const payLoad = {
            "method": "startVoting2",
            "game": game,
            "myClient": myClient
        }
        socket.emit('startVoting', payLoad)
    })


    Client:
    socket.on('startVoting', response => {
        var info = document.getElementById("info")
        var game = response.game;
        var gameId = game.id;
        var myClient = response.myClient;
        var infoArray = info.innerHTML.split(',')
        var playerlistArray = playerlist.innerHTML.split(',')
        var body = document.getElementById("body")
        var clients = infoArray.splice(0, 1);

        //Voting Chart
        const ctx = document.getElementById('myChart').getContext('2d');
        const myChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                label: '# of Votes',
                data: [],
                backgroundColor: [
                    'rgba(255, 99, 132, 0.2)',
                    'rgba(54, 162, 235, 0.2)',
                    'rgba(255, 206, 86, 0.2)',
                    'rgba(75, 192, 192, 0.2)',
                    'rgba(153, 102, 255, 0.2)',
                    'rgba(255, 159, 64, 0.2)'
                ],
                borderColor: [
                    'rgba(255, 99, 132, 1)',
                    'rgba(54, 162, 235, 1)',
                    'rgba(255, 206, 86, 1)',
                    'rgba(75, 192, 192, 1)',
                    'rgba(153, 102, 255, 1)',
                    'rgba(255, 159, 64, 1)'
                ],
                borderWidth: 1
                }]
            },
            options: {
                plugins: {
                legend: {
                    display: false
                }
            },
                scales: {
                    y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    },
                    max: 8
                    }   
                }
            }
        });


        var chartContainer = document.getElementById("myChart");
        chartContainer.style.visibility = "visible";
        var i = 0;
                    
        infoArray.forEach(c => {
            myChart.data.labels.push('Player' + (i+1))
            myChart.data.datasets.forEach((dataset) => {
            dataset.data.push(0);
            });
            body.innerHTML += 
                "<div class='voting'><div class='votingPicture'><img src='data:image/png;base64," + game.clients[i].img +
                "' alt='Red dot'/ id='img'></div><br>" + 
                "<div class='votingBox'><button class='votingButton' onclick=voted(" +
                i + "," + myClient + ")>Vote for Player" + (i+1) + "</div></div>";

                localStorage.setItem("gameId", gameId)
                i++;
        })
        myChart.update();


    })
\end{lstlisting}

Der nächste Abschnitt wird aufgerufen wenn ein User abgestimmt hat. Der Server wird benachrichtigt und überprüft mit einer Schleife ob der User 
schon einmal gevoted hat. Hat er dies nicht getan, wird ein boolean auf true gesetzt. 
Danach wird der User aus dem playerVotes.clients-Array herausgelöscht, um ihn nicht nocheinmal abstimmen zu lassen. Die Zeichnung für die abgestimmt wurde(voteGame.vote[votedPlayer]) wird um 1 erhöht und alle User in der Lobby werden benachrichtigt. 
Ist im playerVotes.clients-Array kein Client mehr vorhanden, bedeutet das, dass alle User gevoted haben und es muss ein Gewinner festgestellt werden. 
Dafür werden alle Zeichnungen durchgegangen und es wird sich der Wert der Votes in ``arr'' gemerkt. Daraufhin wird der Index des höchsten Werts des Arrays herausgefunden. TODO
Damit kann die Gewinnermap in der game Variable gespeichert werden und allen Usern wird vermittelt, dass das Spiel starten kann. 
\begin{lstlisting}[language=html,caption= User voted]
    
    Server:
    socket.on('voted', message => {
        const gameId = message.gameId;
        const game = games[gameId];
        const votedPlayer = message.votedPlayer;
        const voteGame = voteGames[gameId];
        const player = message.player;
        var i = 0;
        var bool = false;
        playerVotes[gameId].clients.forEach(c => {
            if (playerVotes[gameId].clients[i].clientId == player) {
                bool = true
            }
            i++;
        })
        if (bool) {
            i = 0;
            playerVotes[gameId].clients.forEach(c => {
                if (playerVotes[gameId].clients[i].clientId == player) {
                    playerVotes[gameId].clients.splice(i, 1)
                }
                i++;
            })
            voteGame.votes[votedPlayer].amount++;
            const payLoad = {
                "method": "voted",
                "voteGame": voteGames[gameId],
                "game": game,
                "votedPlayer": votedPlayer
            }
            let gameString = "" + gameId
            io.in(gameString).emit('voted', payLoad)
            if (!playerVotes[gameId].clients[0]) {
                var arr = [];
                for (var i = 0; i < voteGame.votes.length; i++) {
                    arr[i] = voteGame.votes[i].amount;
                }
                var winner = arr.reduce((iMax, x, i, a) => x > a[iMax] ? i : iMax, 0);
                let gewinner = games[gameId].clients[winner].img;
                let gewinnerMap = games[gameId].clients[winner].map
                games[gameId].winner = gewinner;
                games[gameId].winnerMap = gewinnerMap;
                var payLoad2 = {
                    "method": "startGame",
                    "game": game,
                }
                let gameString = "" + gameId
                console.log(gameString);
                io.in(gameString).emit('startGame', payLoad2)
            } else {
                console.log("Still Players remaining")
            }
        } else {
            var payLoad2 = {
                "method": "error",
                "message": "user has already voted"
            }
            let gameString = "" + gameId
            console.log(gameString);
            io.in(gameString).emit('error', payLoad)
        }
    })
    


    Client:
    socket.on('voted', response => {
        const myChart = Chart.getChart('myChart')
        var voteGame = response.voteGame;
        var i = response.votedPlayer;
        myChart.data.datasets[0].data[i] = voteGame.votes[i].amount;
        myChart.update();
    })

    socket.on('startGame', response => {
        const game = response.game;
        const gameId = game.id;
        window.location.href = 'http://localhost:3000/' + gameId;
    })
    
\end{lstlisting}
Im Frontend wird zuerst das Diagramm geupdatet und sollten alle User gevoted haben, wird auf das Spiel verlinkt, mit der GameId als Parameter.

\subsection{Game Socketverbindung zur Lobby}
Bei der Initialisierung des Webgames wird eine Funktion namens ``getGame()'' aufgerufen. Diese holt sich aus der URL den GameID Parameter und benachrichtigt den Server. 
Der Server schickt dann dem Client das Gewinnerbild mit dem zugehörigen Map-Array. 
Hat der Client die Response erhalten, setzt er das Hintergrundbild und der Kampf kann beginnen.
\begin{lstlisting}[language=html,caption=Webgame Socket]
    
    Server:
    socket.on('rafi_game', message => {
        const gameId = message.gameId;
        const game = games[gameId];
        const img = games[gameId].winner;
        const map = games[gameId].winnerMap;
        const payLoad = {
            "method": "rafi_game",
            "img": img,
            "map": map
        }
        socket.emit('rafi_game', payLoad)
    })


    Client:
    function getGame() {
        var pathArray = window.location.pathname.split('/');
        var gameId = pathArray[1];
        console.log("")
        const payLoad = {
            "method": "rafi_game",
            "gameId": gameId,
        }
        lobbySocket.emit('rafi_game', payLoad)
    }

    dummy = message.img;
    dummyMap = message.map;
    pixel_clumps = JSON.parse(dummyMap);
    var path_image_dummy = 'data:image/png;base64,' + dummy;
    var backgroundImage = new Image();
    backgroundImage.src = 'data:image/png;base64,' + dummy;
  
    backgroundImage.onload = function () {
        ...
    }
    
\end{lstlisting}

\setauthor{Himmetsberger Jonas}
\input{./sections/Jonas/mapandai.tex}


% Siehe tolle Daten in Tab. \ref{tab:impl:data}.

% \begin{table}
%     \centering
%     \begin{tabular}{|lcc|}
%         \hline
%                   & \textbf{Regular Customers} & \textbf{Random Customers} \\ \hline
%         Age       & 20-40                      & \textgreater{}60          \\ \hline
%         Education & university                 & high school               \\ \hline
%     \end{tabular}
%     \caption{Ein paar tabellarische Daten}
%     \label{tab:impl:data}
% \end{table}

% \begin{figure}
%     \centering
%     \includegraphics[scale=0.5]{pics/knuthi.jpg}
%     \caption{Don Knuth -- CS Allfather}
%     \label{fig:impl:knuth}
% \end{figure}

% Siehe und staune in Abb. \ref{fig:impl:knuth}.
% \lipsum[6-9]
% Dann betrachte den Code in Listing \ref{lst:impl:foo}.

% \begin{lstlisting}[language=Python,caption=Some code,label=lst:impl:foo]
% # Program to find the sum of all numbers stored in a list (the not-Pythonic-way)

% # List of numbers
% numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]

% # variable to store the sum
% sum = 0

% # iterate over the list
% for val in numbers:
%     sum = sum+val

% print("The sum is", sum)
% \end{lstlisting}