\section{Web-Game [R]}
\setauthor{Rafetseder Tobias}
\subsection{Frontend [R]}
Für die Umsetzung des Frontends wird p5.js beziehungsweise p5.play.js verwendet.
Eine detaillierte Beschreibung zu diesen JavaScript-Bibliotheken und wie sie in ein Projekt eingebunden werden kann, wird in Kapitel \ref{subsection:p5js} genau beschrieben.
p5.play.js basiert auf einer Sprite Klasse. Diese Sprite-Klasse hat einige praktische vordefinierte Funktionen für zum Beispiel Collisiondetection oder Animation-Support.
Um einen Sprite zu erstellen, wird einfach die Funktion createSprite() aufgerufen.
\\
\begin{lstlisting}[language=Java,label=lst:impl:createSprite]
    function setup() {
        createCanvas(1920,1080);
        // create a sprite
        createSprite(50,50,30,30);
    }

    function draw() {
        // draw all the sprites added to the sketch so far
        // the positions will be updated automatically at every cycle
        drawSprites();
    }
\end{lstlisting}


Es ist zu beachten, dass die ersten 2 Parameter der Funktion jeweils die Position am Bildschirm in Pixel angeben, und die letzten 2 die Breite und die Höhe definieren.
Das Ergebnis:
\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/simpleSprite.PNG}
    \caption{Einfacher Sprite}
\end{figure}

Es ist noch nicht viel zu sehen, nur ein simpler Sprite, der default-mäßig ein einfaches Rechteck mit zufälliger Farbe auf einer Position erschienen ist.
Für den Spieler, der in dem Canvas angezeigt werden soll, wird diese Sprite-Klasse noch um ein paar Attribute erweitert:

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/playerClass.PNG}
    \caption{Player-Klasse}
\end{figure}

Zum Erstellen der Player-Klasse wird zwar ein Sprite benötigt, damit der Player am Bildschirm angezeigt wird, aber es werden noch einige Attribute ergänzt:
\begin{compactitem}
    \item id: Zur eindeutigen Identifizierung
    \item knockback: Wert, der erhöht wird, desto öfter der Spieler getroffen wird; desto höher der Wert, desto weiter wird der Spieler von Projektilen weggestoßen
    \item death: Anzahl, wie oft der Spieler gestorben ist
    \item kills: Anzahl an Kills, die der Spieler gemacht hat (Abschüsse, die dazu geführt haben, dass der Gegner hinuntergefallen ist)
    \item dmgDealt: Anzahl, wie oft der Spieler jemanden getroffen hat
    \item item: Array von Items, die der Spieler gerade besitzt
    \item direction: String, der die Richtung angibt, in die der Spieler gerade schaut (links oder rechts)
\end{compactitem}

Während des Spiels werden auf der Map Items gespawned. Welcher Algorithmus dahinter steckt, wird im Kapitel \ref{impl:xCoordinates} genauer beschrieben.
Es wird zwischen 5 unterschiedlichen Items entschieden. Eine Item-Klasse hat ähnlich wie die Player-Klasse als Hauptbestandteil einen Sprite, doch auch hier werden noch weitere Attribute benötigt.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/itemClass.PNG}
    \caption{Item-Klasse}
\end{figure}

\begin{compactitem}
    \item type: Gibt den Typ des Items an
    \item dropped: Gibt an, ob das Item irgendwo auf der Umgebung gelandet ist
    \item ammo: Anzahl, wie oft der Spieler das Item benutzen kann
\end{compactitem}

Je nachdem, welchen Typ das Item bekommen hat, wird auch die Anzahl wie oft
der Spieler es benutzen kann, verändert.
Wurde es zum Beispiel zum Type "bomb", kann der Spieler 5 Mal eine Bombe werfen.
\\
Bei dem Typ "mine", also einer Mine, kann der Spieler mehrere Minen gleichzeitig legen, deshalb ist das Sprite-Attribut auch ein Array.
Bei den anderen Items kann immer nur ein Sprite davon existieren.




\subsubsection{Die Items}  \label{impl:items}
Grundsätzlich gibt es 5 unterschiedliche Items in ScribbleFight. Je nachdem, welches Item der Spieler aufgesammelt hat, kann er oder sie verschiedene Fähigkeiten aktivieren.
Für jedes Item existiert eine Physik-Methode, die in der Draw-Funktion aufgerufen wird. Diese ist dafür verantwortlich, die physischen Eigenschaften der Items darzustellen. (zum Beispiel Gravitation)

\textbf{Keyboard-Access}
\\
Die Items werden alle durch Tasten auf der Tastatur ausgelöst. Durch p5.js kann sehr leicht auf die Tastatur zugriffen werden.
Mit der p5.js Methode <keyWentDown(Key)> wird überprüft, ob eine Taste gerade gedrückt wurde. (Als Parameter wird der ASCII-Code der gewünschten Taste übergeben)

\begin{lstlisting}[caption=Keyboard-Access,language=Java,label=lst:impl:keyboard-access]
    // E
    if (keyWentDown(69)) {
        bombAttack();
    }
    // Q
    if (keyWentDown(81)) {
        blackHoleAttack();
    }
    // R
    if (keyWentDown(82)) {
        pianoTime();
    }
    // C
    if (keyWentDown(67)) {
        placeMine();
    }
    // F
    if (keyWentDown(70)) {
        makeMeSmall();
    }
\end{lstlisting}

\textbf{Bomb}
\\
\textit{Das Bomben-Item wird mit der Taste <E> aktiviert.}
\\
Durch p5.play.js kann die vertikale Geschwindigkeit eines Sprites mit <sprite.velocity.y> verändert werden. Dadurch kann eine Gravitation simuliert werden.
Außerdem können mit der Methode <sprite.bounce(otherSprite)> Sprites an anderen Sprites oder Gruppen von Sprites 'abspringen'. Dies wird benutzt, damit die Bombe an der Umgebung abprallt.
Danach wird mit <sprite.overlap(myPlayer.sprite)> überprüft, ob eine Bombe mit meinem Spieler-Sprite kollidiert.
Falls ja, wird die Bombe mit <sprite.remove()> entfernt und mein Spieler wird weggestoßen.
Falls nein, wird noch überprüft, ob sich die Bombe außerhalb des Bildschirms befindet, und falls dies zutrifft, wird auch in diesem Fall die Bombe entfernt.
\\

\begin{lstlisting}[caption=Bomb Item Physics,language=Java,label=lst:impl:bombGravity]
    // verringern der vertikalen Geschwindigkeit 
    bomb.velocity.y -= GRAVITY;
    // bombe prallt an der Umgebung ab
    bomb.bounce(environment);

    // kollidert die Bombe mit meinem Player
    if(bomb.overlapSprite(myPlayer.sprite)) {
        // my Player gets knocked back
        myPlayer.sprite.getsThrownAway();
        // bomb gets deleted
        bomb.remove();
    } else if(bombIsOutsideMonitor()) {
        // bomb gets deleted
        bomb.remove();
    }

\end{lstlisting}

\textbf{Black Hole}
\\
\textit{Das Black-Hole-Item wird mit der Taste <Q> aktiviert}.
\\
Wie bei dem Bomben-Item wird auch bei dem Black-Hole-Item Gravitation simuliert. Jedoch nur für eine kurze Zeit, bis das Item in der Luft stehen bleibt und in einem Radius alle Spieler, die sich in diesem Radius befinden, anzieht, und diese auch alle Fähigkeiten nimmt.
Um zu überprüfen, wie lange das Item schon existiert, stellt p5.play.js das <life>-Attribut zur Verfügung. Dieser Wert ist ein Countdown, der sich bei jedem Draw-Zyklus um 1 verringert, bis sich das Item dann bei dem Wert 0 selbst löscht.
Damit das Item funktionieren kann, muss es andere Sprites anziehen können. Dazu wurde die attraction-Funktion von p5.play.js (mit leichten Veränderungen) benutzt:

\begin{lstlisting}[caption=Attraction,language=Java,label=lst:impl:attraction]
    // attraction
    if (myPlayer.sprite.overlap(b)) {
        noGravity = true;
        var angle = atan2(myPlayer.sprite.position.y - b.position.y, myPlayer.sprite.position.x - b.position.x);
        if (myPlayer.sprite.velocity.y >= -pixelWidth && myPlayer.sprite.velocity.y <= pixelWidth) {
          myPlayer.sprite.velocity.x -= cos(angle);
        }
        myPlayer.sprite.velocity.y -= sin(angle);
      }

\end{lstlisting}

Die Black-Hole-Physics Funktion sieht also (vereinfacht) so aus:
\\
\begin{lstlisting}[caption=Black Hole Item Physics,language=Java,label=lst:impl:bombGravity]
    // if the item has reached a certain life, make it static and attract players
    if (b.life <= 400) {
        attraction(b);
        b.velocity.y = 0;
        b.velocity.x = 0;
      }

      // if the item has not reached a certain life, let it bounce off the environment
      if (b.life > 400) {
        b.velocity.y -= GRAVITY;
        b.bounce(environment);
      }

      // if the item is outside of the monitor, delete it
      if (b.position.x > windowWidth || b.position.y > windowHeight || b.life == 0) {
        b.remove();
      }

\end{lstlisting}

\textbf{Piano}
\\
\textit{Das Piano-Item wird mit der Taste <R> aktiviert.}
\\
Das Piano-Item ist, wie der Namen schon vermuten lässt, ein Klavier, das am höchsten Punkt der Map erscheint und nach unten fällt.
Das bedeutet, die y-Koordinate ist 0 und die x-Koordinate ist die selbe wie die, die der Sprite des Spielers hat, der das Piano aktiviert hat.
Bei Kontakt zu einem Spieler oder der Umgebung wird das Klavier zerstört. Zum Überprüfen auf Kollisionen wird die p5.js Methode <sprite.collide(otherSprite)> verwendet.
Diese erhält den Wert \texttt{true}, falls eine Kollisionen zwischen zwei Sprites oder Sprite-Gruppen stattfindet.
\\
\begin{lstlisting}[caption=Piano-Item Physics,language=Java,label=lst:impl:pianoPhy]
    // check for collisions
    if (p.collide(environment)) {
        p.remove();
      } else if (p.overlap(myPlayer.sprite)) {
        myPlayer.sprite.getsThrownAway()
        p.remove();
      }
      p.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Mine}
\\
\textit{Das Minen-Item wird mit der Taste <C> aktiviert.}
Das Minen-Item ist das einzige Item, bei dem der Spieler mehrere Instanzen auf einmal entsenden kann.
Es taucht hinter dem eigenen Player-Sprite auf und fliegt so lange nach unten, bis es auf der Umgebung landet. Erst wenn es wo gelandet ist, wird es 'aktiv'.
Wenn eine Mine aktiviert worden ist, und ein Spieler in Berührung mit dem Item kommt, wird dieser in die Luft gestoßen und die Mine wird gelöscht.
\\
\begin{lstlisting}[caption=Mine-Item Physics,language=Java,label=lst:impl:minePhy]
    // check if mine has landed somewhere (if true: activate mine)
    if (m.collide(environment) && m.touching.bottom) {
        m.set = true;
    }
    if (m.overlap(myPlayer.sprite) && m.set) {
        myPlayer.sprite.getsThrownAway();
        m.remove();
    }
    m.velocity.y -= GRAVITY;
\end{lstlisting}

\textbf{Size-Reduction}
\\
\textit{Das Size-Reduction-Item wird mit der Taste <F> aktiviert.}
\\
Dieses Item ist das einzige, das keinen eigenen Sprite hat. Das einzige was diese Item macht, ist, den Spieler-Sprite zu verkleinern. Dadurch wird dieser schwieriger zu treffen.
Wenn das Item aktiviert wird, wird der Sprite des Spielers verkleinert und ein Counter wird gestartet. Dieser wird alle 60 Frames um eins verringert. Ist der Counter 0, wird der Sprite wieder in seine Originalgröße gebracht.
Der Code, der dies umsetzt, sieht vereinfacht so aus:
\\
\begin{lstlisting}[caption=Size-Reduction,language=Java,label=lst:impl:sizeReduc]
// gets called on key press F
function makeMeSmall() {
  if (doIHaveTheItem()) {
    imSmall = true;
    smallTimer = 10;
  }
}

// gets called in draw function
function smallChecker() {
  if (imSmall) {
    // scale the sprite down at the start of countdown
    if (smallTimer == 10) {
      myPlayer.sprite.scale = 0.6;
    }
    // every second (60 frames), the countdown gets reduced
    if (frameCount % 60 == 0 && smallTimer > 0) {
      smallTimer--;
    }
    // if the countdown is over, rescale the sprite back to the original form
    if (smallTimer == 0) {
      myPlayer.sprite.scale = 1;
      smallTimer = 10;
      imSmall = false;
    }
  }

}
\end{lstlisting}

\textbf{Die Default-Attacke}
\\
\textit{Die Default-Attacke wird mit <Left-Click> aktiviert.}
\\
p5.js bietet sehr leicht die Möglichkeit, auf User-Input zu überprüfen. Das einzige, was nötig ist um zu erkennen, ob der User gerade die linke Maustaste geklickt hat, ist die Funktion <mouseClicked()>.
Mit dieser Funktion wird nun zu dem Punkt, auf dem der Spieler gerade die Maus hält und die Default-Attacke aktiviert, ein Projektil abgeschossen. Um die Information zu erhalten, auf welcher X- und Y-Position sich die Maus befindet,
werden die von p5.js vordefinierten Eigenschaft <camera.mouseX> und <camera.mouseY> verwendet.
\\
\begin{lstlisting}[caption=Default-Attacke,language=Java,label=lst:impl:defaultAttack]
    function mouseClicked() {
    // Maus-Position
    let x = camera.mouseX,
        y = camera.mouseY;
    // Sprite wird bei meiner Player-Sprite-Positon erstellt
    projectile = createSprite(myPlayer.sprite.position.x, myPlayer.sprite.position.y, pixelWidth, pixelWidth);
      
    // Geschwindigkeit wird auf die Position der Maus ausgerichtet
    projectile.velocity.x = (x - myPlayer.sprite.position.x);
    projectile.velocity.y = (y - myPlayer.sprite.position.y);
}

\end{lstlisting}

\subsubsection{Movements}
Es gibt 3 fundamentale Bewegungsmöglichkeiten in ScribbleFight. Springen, links/rechts laufen und 'klettern'. Diese Bewegungen werden im Folgenden genauer erläutert.

\textbf{Springen}
\\
In dem Web-Game kann der Spieler mittels Leertaste springen. Genau wie bei den Item-Aktivierungen, wird mithilfe von p5.js Methoden der User-Input ermittelt.
Bei dem Springbewegung wird einfach die vertikale Geschwindigkeit des Spieler-Sprites so verändert, dass dieser etwas nach oben springt.
\\
\begin{lstlisting}[caption=Jumping,language=Java,label=lst:impl:jumping]
    // check if user pressed spacebar
    if (keyWentDown(32)) {
        jump()
    }

    function jump() {
    // user is only allowed to jump 2 times (it resets when touching the ground)
    if (!(JUMP_COUNT >= MAX_JUMP)) {
        // make the user fly up a bit (JUMP is a global variable)
        myPlayer.sprite.velocity.y = -JUMP;
        JUMP_COUNT++;
    }
}
\end{lstlisting}

\textbf{Links/Rechts Laufen}
\\
Das Prinzip des Links oder Rechts Bewegens ist sehr simpel. Es wird einfach die horizontale Geschwindigkeit des Player-Sprites auf eine konstante Variable gesetzt.
Wenn sich der Spieler nach rechts bewegt, ist diese Konstante positiv, bei einer Linksbewegung negativ. Im Gegensatz zur Springbewegung wird diesmal aber die Methode <keyIsDown(key)> verwendet, und nicht <keyWentDown(key)>.
Der Grund dafür ist, dass die Bewegung so lange anhalten soll, wie der User die Taste drückt, und nicht nur einmal pro Tastendruck.

\begin{lstlisting}[caption=Links/Rechts-Movement,language=Java,label=lst:impl:moving]
    //A
    if (keyIsDown(65)) {
        moveLeft()
    }
    //D
    if (keyIsDown(68)) {
        moveRight()
    }

    // SPEED is a global variable
    function moveLeft() {
    myPlayer.sprite.velocity.x = -SPEED;
    }

    function moveRight() {
    myPlayer.sprite.velocity.x = SPEED;
    }
\end{lstlisting}

\textbf{Bewegung auf der Spielumgebung}
\\
Die Bewegung auf der Spielumgebung wird durch die Methode <collisions()> bestimmt. Diese wird in der draw-Methode aufgerufen und wird somit 60 mal die Sekunde ausgeführt.
Berührt der Sprite des Players nichts, fällt er er mit konstanter Geschwindigkeit nach unten.
Findet jedoch eine Kollision mit der Spielumgebung statt, dann wird überprüft, welche Art von Berührung gerade stattfindet:

\begin{compactitem}
    \item Falls Berührung seitlich stattfindet: Player-Sprite bekommt eine Klettergeschwindigkeit und behält diese so lange, wie die Berührung stattfindet
    \item Falls Berührung unten stattfindet: Die vertikale Geschwindigkeit des Player-Sprites wird auf 0 gesetzt und der Sprung-Counter zurückgesetzt
    \item Falls Berührung oben stattfindet: Mit einer Berührung die zwischen Spielumgebung und Sprite stattfindet, kann der Spieler oder die Spielerin weder 'klettern' noch wird der Sprung-Counter zurückgesetzt
\end{compactitem}

\begin{lstlisting}[caption=Bewegung auf der Spielumgebung,language=Java,label=lst:impl:collisions]
    // check for collisions
    if (myPlayer.sprite.collide(environment)) {
      // if the collision is on the side, the sprite will start "climbing" with a certain speed
      if (myPlayer.sprite.touching.left || myPlayer.sprite.touching.right) {
        myPlayer.sprite.velocity.y = CLIMBINGSPEED;
      }
      // standing on the environment
      if(myPlayer.sprite.touching.bottom) {
        myPlayer.sprite.velocity.y = 0; 
      }
      // jump count gets only reset when the collision is not on the top of the player-sprite
      if (!myPlayer.sprite.touching.top) {
        JUMP_COUNT = 0;
      }
    }
\end{lstlisting}

\textbf{Knockback-Bewegung} \\
Wenn der Spieler von einem Projektil getroffen wurde, wird der eigene Player-Sprite für kurze Zeit bewegungsunfähig und prallt von der Spielumgebung ab.
Wie lang dieses Knockback-Movement andauert, kommt auf die Art des Projektils und auf den Wert des Knockbacks des Players an.
Soll der Player-Sprite also nun diese Bewegung ausführen, wird das mit einer Funktion namens <sendHimFlying()> bewerkstelligt.
Bevor diese aufgerufen wird, muss noch der Countdown, wie lange der Sprite nun in dieser Bewegung bleiben soll, festgelegt werden. Bei jedem draw-Zyklus wird dieser Countdown um den Wert eins verringert.
Hinzu kommt, dass wenn der Spieler getroffen wurde, er kurz etwas verlangsamt wird. Es soll so wirken, als wäre er gerade etwas betäubt worden.
\begin{lstlisting}[caption=Knockback-Bewegung,language=Java,label=lst:impl:knockbackMov]
// before function gets called, make sure to set flying to true and set a flying-duration
function sendHimFlying() {
  if (flying) {
    timeFlying--;
    //slowdown but only at the first half of flying-duration
    if (timeFlying <= flyingDuration / 2 && timeFlying > 0) {
      if (myPlayer.sprite.velocity.x > 0) { myPlayer.sprite.velocity.x -= 0.3; }
      if (myPlayer.sprite.velocity.x < 0) { myPlayer.sprite.velocity.x += 0.3; }
      if (myPlayer.sprite.velocity.y > 0) { myPlayer.sprite.velocity.y -= 0.3; }
      if (myPlayer.sprite.velocity.y < 0) { myPlayer.sprite.velocity.y += 0.3; }
    }
    // flying-duration is over
    if (timeFlying == 0) {
      flying = false;
    }
  }
}
\end{lstlisting}


\textbf{Richtungswechsel des Sprites} \label{directionChange}
\\
Ein weiterer wichtiger Aspekt bei der Bewegung des Player-Sprites ist, dass sich auch die Orientierung des Bildes ändern muss, wenn dieser die Richtung wechselt.
Auch für diese Problemstellung stellt p5.play.js eine Lösung zu Verfügung. Mit der Methode <mirrorX()> wird der Sprite entlang seiner vertikalen Achse gespiegelt.
Jedes mal, wenn der User nun also die Richtung seines Player-Sprites wechselt, wird auch der Sprites passend seiner Bewegung gespiegelt.

\begin{lstlisting}[caption=Sprite Richtungswechsel,language=Java,label=lst:impl:mirrorSprite]
    function mirrorSprite() {
        // A
        if (keyWentDown(65)) {
            mirrorSpriteLeft()
        }
        // D
        if (keyWentDown(68)) {
            mirrorSpriteRight()
        }
    }
    
    function mirrorSpriteLeft() {
        // if the mirrorX attribute is 1, then the sprite is looking to the right
        if (myPlayer.sprite.mirrorX() === 1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "left";
        }
    }
    
    function mirrorSpriteRight() {
        // if the mirrorX attribute is 1, then the sprite is looking to the left
        if (myPlayer.sprite.mirrorX() === -1) {
            myPlayer.sprite.mirrorX(myPlayer.sprite.mirrorX() * -1);
            myPlayer.direction = "right";
        }
    }
\end{lstlisting}

\subsubsection{Wie gewinne ich?} \label{impl:win}
Um in ScribbleFight zu gewinnen, muss der Spieler oder die Spielerin seinen Gegner/seine Gegner drei mal erfolgreich von der Spielumgebung schießen, so, dass der Sprite des Gegners ins 'Nichts' fällt.
Dies ist durch die Attacken, die in Kapitel \ref{impl:items} genau beschreiben werden, möglich.
Um zu überprüfen, ob der Sprite nun hinuntergefallen und somit 'gestorben' ist, wird in der draw-Methode die Funktion <deathCheck()> aufgerufen.
Diese hat einige Aufgaben:
\begin{compactitem}
    \item Überprüfen ob sich der Player-Sprite außerhalb des Bildschirms befindet
    \item Falls ja, überprüfen ob der Player noch mindestens ein Leben hat
    \item Falls der Player keine Leben mehr hat, wird sein Sprite zerstört
    \item Hat der Player noch weitere Leben, dann wird er nach drei Sekunden an einem zufälligen Punkt, an dem er nicht direkt wieder aus dem Bildschirm fällt, gespawned
    \item Wird der Player respawned, werden ihm alle seine Items, die er eventuell noch hatte, wieder genommen
    \item Wird der Player respawned, wird sein Knockback wieder zurückgesetzt
\end{compactitem}

Vereinfacht sieht die Methode also so aus:

\begin{lstlisting}[caption=Überprüfung nach Toden,language=Java,label=lst:impl:deathCheck]
function deathCheck() {
    // check if sprite has fallen outside of the monitor
    if (myPlayer.sprite.position.y - player_height > windowHeight) {
        youDied();
    }
}

function youDied() {
    myPlayer.removeItem();
    myPlayer.death++;
    myPlayer.knockback = 1;

    // after 3 seconds the player gets respawned on a location, if he still has at least one live left
    setTimeout(() => {
        if (myPlayer.death < 3) {
            myPlayer.sprite.position.x = xCoordinates[Math.floor(Math.random() * xCoordinates.length)];
            myPlayer.sprite.position.y = 0;
        }
    }, 3000);
}
\end{lstlisting}

Außerdem zählt es auch als Tod, wenn der Knockback des eigenen Players über einen gewissen Wert ansteigt. Dies wird mit der <fatalHit()>-Methode überprüft.
Diese Methode wird immer dann aufgerufen, wenn der eigene Player von irgendeinem Projekil getroffen wurde.
\begin{lstlisting}[caption=Fatal Hit,language=Java,label=lst:impl:fatalHit]
    function fatalHit() {
        if (myPlayer.knockback > MAX_KNOCKBACK) {
            youDied();
        }
    } 
\end{lstlisting}
Ein Indikator, ob der Spieler gut abgeschnitten hat, sind die Kills, die er erzielen konnte.
In ScribbleFight kann der Spieler Kills sammeln, indem er jemanden mit jeglicher Art von Projektil trifft, und dieser innerhalb von 3 Sekunden aus der Spielumgebung fliegt.
Dies funktioniert so, dass wenn jemand meinen player-Sprite trifft, in meinem Player-Objekt abgespeichert wird, welcher Spieler mich gerade getroffen hat.
Diese Information wird aber alle 3 Sekunden wieder gelöscht.

\begin{lstlisting}[,language=Java]
    function draw() {
        // every second, the countdown gets reduced by 1
        if (frameCount % 60 == 0 && damagedByTimer > 0 && myPlayer.damagedBy != null) {
            damagedByTimer--;
          }
      
        // if the countdown has reached 0, the information gets deleted and the countdown restarts
        if (damagedByTimer == 0) {
            damagedByTimer = 3;
            myPlayer.damagedBy = null;
        }
    }
   
\end{lstlisting}


Wenn ich nun sterbe, und die Information, dass mich jemand getroffen hat in meinem Player-Objekt gespeichert ist, bekommt dieser einen Kill.



\subsubsection{Erstellung der Spielumgebung} \label{impl:Spielumgebung}
Um sich auch auf dem Bild, das der User gezeichnet hat, bewegen zu können, müssen einiges Schritte durchgeführt werden. Mittels Objekterkennung kann das Bild abfotografiert,
und daraus ein Array mit Bildaten erstellt werden, aus dem dann die Spielumgebung kreiert wird. Wie genau dieser Array zustande kommt, wird in Kapitel \ref{maai:udbifdsbd:head} beschrieben.
\\
\begin{lstlisting}[caption=Vereinfachte Darstellung eines Bilddaten-Arrays,language=Java,label=lst:impl:bilddaten]
    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
    [255, 255, 255, 0], [252, 252, 252, 0], [251, 251, 251, 0],
    [248, 248, 248, 0], [249, 249, 249, 0], [247, 247, 247, 0],
    [255, 255, 255, 0], [240, 240, 240, 0], [250, 250, 250, 0],
    [174, 174, 174, 0], [255, 255, 255, 0], [173, 173, 173, 0],
    [226, 226, 226, 0], [255, 255, 255, 0], [253, 253, 253, 0],
    [163, 163, 163, 0], [254, 254, 254, 0], [255, 255, 255, 0],
    [0, 0, 0, 0], [0, 0, 0, 0], [[0, 0, 0, 0],
\end{lstlisting}


Desto genauer dieser Array ist, desto genauer werden auch die Hitboxen der Spielumgebung, denn die gezeichneten Formen werden mit Rechteck-Hitboxen nachgestellt.
Eine Hitbox ist ein Bereich, der für die Berechnung für Kollision benutzt wird.
Hat ein Eintrag des Arrays an Stelle vier mehr als 0 als Wert, wird dort ein Pixel erstellt. Das liegt daran, dass an der vierten Stelle eines solchen Eintrags die Deckkraft der Bildstelle angegeben wird. Das bedeutet, der User hat dort etwas gezeichnet.
Natürlich muss der Sprite-Pixel noch einen richtigen X- und Y-Wert bekommen. Diese Koordinate muss auch mit dem Punkt des Bildes übereinstimmen, an den der Sprite als Hitbox agieren soll.
Aus Perfomance-Gründen (Es wird durchgehend auf Kollidierung zwischen Player und Spielumgebung geprüft) werden die Sprite-Pixel entlang der X-Achse noch zusammengefasst.
Wurden nun alle Sprite-Pixel ausfindig gemacht, mit richtigen Koordinaten versehen und entlang der horizontalen Achse zusammengefasst, werden alle einer p5-Group-Variable hinzugefügt.
Das macht das Überprüfen auf Kollision sehr leicht. \\
Die nächsten drei Bilder sollen den Ablauf bildlich darstellen.

Zuerst das originale, vom User gezeichnete Bild.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing.PNG}
    \caption{Originale Zeichnung}
\end{figure}

Aus diesem Bild kann ein Array aus Bilddaten erstellt werden. Wenn aber einfach mit diesem Array
die Pixel für die Spielumgebung erstellt, sind diese noch viel zu klein und an der falschen Position.
\\
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{pics/simpleDrawing2.PNG}
    \caption{Bilddaten-Array bildich dargestellt}
\end{figure}

Um die richtigen Koordinaten für die Sprite-Pixel zu bestimmen, werden noch einige andere Faktoren miteinbezogen und daraus dann die richtige Position der Pixel am Bildschirm ermittelt.
Außerdem werden sie noch entlang der X-Achse kombiniert.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.75]{pics/simpleDrawing3.PNG}
    \caption{Spielumgebung}
\end{figure}

Natürlich werden dann diese Sprites versteckt. Es soll ja so wirken, also würde sich der User auf dem, was er gerade gezeichnet hat, bewegen können.
Im Folgenden wird der Algorithmus zum Aufbereiten der Spielumgebung vereinfacht dargestellt.
\begin{lstlisting}[,language=Java,label=lst:impl:createEnv]
    environment = new Group();
    // looping through image data array
    for (let i = 0; i < pixel_clumps.length; i++) {
      sprite_pixels[i] = [];
      for (let j = 0; j < pixel_clumps[0].length; j++) {
        if the value is greater than 0, then something has been drawn there
        if (pixel_clumps[i][j][3] > 0) {
          //if the last value in the array is not undefined, we can merge the sprite-pixels
          if (sprite_pixels[i][j - 1] !== undefined) {
            same_x_counter++;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth * faktorY, pixelWidth * same_x_counter, pixelWidth);
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
            // remove the last value, because it has been replaced by a new sprite, with a greater width
            sprite_pixels[i][j - 1].remove();
            sprite_pixels[i][j - 1] = undefined;
          } else {
            same_x_counter = 1;
            sprite_pixels[i][j] = createSprite(pixelWidth * faktorX, pielWidth * faktorY, pixelWidth, pixelWidth); 
            // add sprite to environment group
            environment.add(sprite_pixels[i][j]);
          }
        }
      }
    }
\end{lstlisting}

\subsubsection{Item-Spawns} \label{impl:itemSpawnF}
Alle 10 Sekunden wird ein Item erstellt.
Es wird an oberster Stelle des Bildschirms kreiert (y-Koordiante = 0); die x-Position dieses Items wird dann zufällig ausgewählt.
Wichtig dabei ist jedoch, dass das Items auf keiner Position spawnen darf, bei der es einfach oben auftaucht und dann aus dem Bildschirm fällt.
Wie diese x-Koordiaten berechnet werden, wird in Kapitel \ref{impl:xCoordinates} genau beschrieben.
Damit die Items voneinander unterschieden werden können, wird jede Art von Item farblich gekennzeichnet:

\begin{compactitem}
    \item Rot: Bomb
    \item Blau: Black-Hole
    \item Gelb: Piano
    \item Orange: Mine
    \item Grün: Size-Reduction
\end{compactitem}

Den Input, wann ein Item genau erstellt wird, (muss bei jedem User der gerade spielt gleich sein) liefert der Server. Genauere Details wie der Server von des Web-Games funktioniert, wird in Kapitel \ref{impl:itemSpawnB} beschrieben.
\\

\begin{lstlisting}[caption=Erstellen eines Items,language=Java,label=lst:impl:createItem]
funciton createItem(data) {
    // number between 1-5 from the server to create a random item
    let num = data.num;
    // random x-Coordinate from the server
    let x = data.x
    // this equation gets you the highest point of the map
    let y = (windowHeight - ImageHeight) / 2;
    // if x = -1, something on the server-side went wrong
    if (x != -1) {
        // itemSize is a global variable
        switch (num) {
            case 1:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "bomb";
                break;
            case 2:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "black_hole";
                break;
            case 3:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "piano";
                break;
            case 4:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "mine";
                break;
            case 5:
                i = createSprite(x, y, itemSize, itemSize);
                i.type = "small";
                break;
        }
        i.dropped = false;
        items.push(i);
    }
\end{lstlisting}

Nachdem nun das Item erstellt wurde, braucht dieses natürlich auch so wie zum Beispiel die Projektile oder der Player eine eigene Physik-Methode. Diese wird, so wie die anderen Physik-Methoden auch, in der Draw-Methode aufgerufen.
Die Methode funktioniert so, dass das Item so lange fällt, bis es irgenwo auf der Spielumgebung landet. Jeder Player kann jeder Zeit das Item berühren und somit eine neue Fähigkeit bekommen.

\begin{lstlisting}[caption=Item-Physik,language=Java,label=lst:impl:itemPhy]
    function itemPickUp() {
        if (items.length > 0) {
            items.forEach(item => {
                // if the item collides with the environment, the dropped-attribute becomes true
                if(item.collide(environment)) {
                    item.dropped = true;
                }
                // if the item has not landed anywhere, let it fall 
                if(!item.dropped) {
                    item.velocity.y -= GRAVITY;
                }
    
                // if I collide with the item, I get a new ability depending on the type of the item and the item gets deleted
                if (item.overlap(myPlayer.sprite)) {
                    myPlayer.item[item.type] = new Item(item.type);
                    deleteItem(item);
                }
        }
    }
    \end{lstlisting}

\textbf{Bestimmung von gültigen X-Koordinaten} \label{impl:xCoordinates}
\\
Mit gültiger X-Koordinaten sind jene X-Koordinaten gemeint, bei denen ein Sprite erstellt werden kann, und dieser dann irgendwo auf der Spielumgebung landet und nicht sofort aus dem Bildschirm fliegt.
Bei dem Algorithmus wird zuerst überprüft, auf welchen Stellen Sprite-Pixel (Pixel aus denen die Spielumgebung besteht) vorhanden sind. Von diesen kann schon der Mittelpunkt als gültige X-Koordiaten genommen werden, solange dieser Pixel eine gewisse Breite aufweist.
Doch damit bei einem sehr breiten Pixel nicht nur eine einzige X-Koordinate ausgewählt wird, wird schrittweise überprüft, ob noch Stellen vor oder hinter dem Mittelpunkt des Sprites in Frage kommen.
Dazu wird dieser Sprite-Pixel nach vorne und nach hinten abgetastet, ob noch genügend Platz da ist, ein Item dort landen zu lassen.
Es können höchstens halb so viele X-Koordiaten pro Sprite-Pixel ausgewählt werden, wie der Pixel (in Pixel-Width gemessen) breit ist.
Die Funktion wird im Setup von ScribbleFight aufgerufen.

\begin{lstlisting}[caption=Bestimmung gültiger X-Koordinaten,language=Java,label=lst:impl:xCoords]
    function getXCoordinates() {
        let sprite;
        // looping through the sprite_pixel array
        for (let i = 0; i < sprite_pixels.length; i++) {
            for (let j = 0; j < sprite_pixels[i].length; j++) {
                sprite = sprite_pixels[i][j];
                // if the sprite variable is not undefined, it means a sprite exists there
                // the sprite hast to be a width of at least 4 times the normal pixel width
                if (sprite !== undefined && sprite.width >= pixelWidth * 4) {
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the right of the center)
                    for (let index = 0; index < sprite.width / 2; index += pixelWidth * 2) {
                        if (sprite.position.x + index < sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index;
                            xCoordinates.push(x);
                        }
                    }
                    // sprites gets checked if there are more Coordinates to let an item spawn there (to the left of the center)
                    for (let index = sprite.width; index > sprite.width / 2; index -= pixelWidth * 2) {
                        if (sprite.position.x + index > sprite.position.x + sprite.width / 2) {
                            let x = sprite.position.x + index - sprite.width;
                            xCoordinates.push(x);
                        }
                    }
                    // doing this eliminates duplicates
                    xCoordinates = Array.from(new Set(xCoordinates));
                }
            }
            return xCoordinates;
        }
    }
\end{lstlisting}

\textbf{Progressbar} \label{impl:progressbar} \\
Um dem Spieler Feedback zu geben, wie oft er getroffen wurde, wird eine Progressbar am oberen Rand des Bildschirms eingefügt. Je öfter man getroffen wurde, desto mehr füllt sich diese.
Wenn die Progressbar komplett aufgefüllt ist, wird der nächste Treffer eines Projektils den Spieler umbringen.
Umgesetzt wurde dieses Feature, indem man den derzeitigen Knockback des Spieler auf den Bereich zwischen 0 bis zur Hintergrundsbild-Breite mapped. Dazu wurde die von p5.js vordefinierte Funktion \texttt{map} verwendet.
Als Parameter nimmt diese Funktion:
\begin{compactitem}
    \item Der umzuwandelnde Wert
    \item Start-Wert des ersten Bereichs
    \item End-Wert des ersten Bereichs
    \item Start-Wert des zweiten Bereichs
    \item End-Wert des zweiten Bereichs
\end{compactitem}
\begin{lstlisting}[language=Java, caption=Progressbar,label=lst:impl:progressbar]
//gets called in setup function
function createUI() {
    // position the progressbar at the top of the background-image
    // at the start, the width is of the progessbar is 0
    progressBar = createSprite(windowWidth/2 ,(windowHeight-ImageHeight) / 2,0, width);
    progressBar.position.x += progressBar.width / 2;
    progressBar.position.y += progressBar.height / 2;
    progressBar.shapeColor = color(255,0,0);
}
// gets called whenever my player is hit
function updateUI() {
  let progress;
  progress = map(myPlayer.knockback,1,MAX_KNOCKBACK,0,newImageWidth);
  progressBar.width = progress;
}
\end{lstlisting}

\subsection{Server [R]}
Der Server von des Spiels ist ein einfacher Web-Server, der mit Node.js und express.js umgesetzt wurde.
Dieser hostet statische Files, auf denen sich der Code für das Frontend befindet (HTML Files, p5.js library, etc).
Viele Teile dieses Codes werden im vorherigen Kapitel detailliert erklärt.
Durch SocketIO können multiple Clients eine Verbindung mit dem Server aufbauen.
So wird es ermöglicht, dass unterschiedliche Clients gemeinsam spielen können.

\subsubsection{Erstellen des Servers}
Ein Node.js Server ist einfach zu erstellen. Zwei Voraussetzungen müssen vorhanden sein:

\begin{compactitem}
    \item Eine funktionierende Node.js-Version
    \item JavaScript Grundlagen
\end{compactitem}

Ist dies gegeben, kann ein neuen Ordner erstellt, und in diesem dann der Befehl \texttt{npm init} ausgeführt werden.
Dort wird dann ein package.json File für das Node-Projekt erstellt. Nähere Infos zu diesem File kann in Kapitel \ref{NPM} nachgelesen werden.
Danach kann entweder durch eine Entwicklungsumgebung ein neues JavaScript File erstellt, oder im Terminal der Befehl \texttt{touch server.js} eingegeben werden.
In dem Backend von ScribbleFight werden express.js und SocketIO benutzt, deshalb müssen die Befehle \texttt{npm install express --save} für express.js, und
\texttt{npm install socket.io} für SocketIO im Terminal ausgeführt werden. Dies installiert die Module und fügt die Dependencies zu dem package.json-File hinzu.

Wurde all das berücksichtigt, wird jetzt die Logik des server.js-Files umgesetzt. Zuerst wird eine Instanz von express.js erstellt.
Danach wird ein HTTP-Server-Objekt und eine SocketIO Instanz angelegt, die das HTTP-Server-Objekt als Paramter nimmt. Zusätzlich wird noch Cross-Origin Resource Sharing freigegeben.
Der Code sieht also so aus:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    var express = require("express");
    var app = express();
    var http = require("http").createServer(app);
    var io = require("socket.io")(http, {
        cors: {
            origin: '*',
        }
    });
\end{lstlisting}

Das war aber nur ein Teil, um einen funktionierenden SocketIO-Webserver zu erstellen. Bei unserem Web-Game müssen, wie vorher schon erwähnt, das Frontend als statische Files gehostet werden.
Für dieses Problem wurde das Paths-Module von Node.js verwendet. Dieses stellt Funktionen für das Arbeiten mit File-und Directory-Pfaden zur Verfügung. Darauf zugegriffen werden wird mit:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    const path = require('path');
\end{lstlisting}

Nun können die Files einfach mit \\

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    // path.join is used to get the right path 
    app.use(express.static(path.join(__dirname, '/../p5_frontend/src')));
\end{lstlisting}

gehostet werden. (Diese befinden sich in dem Folder <src>);

Als letzten Schritt wird noch der Port bei dem HTTP-Server-Objekt angegeben, im Fall von unserem Server ist dieser 3000.
\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    // Server is listening on port 3000
    http.listen(3000);
\end{lstlisting}

Ist das alles abgeschlossen, wird nun die SocketIO Logik umgesetzt.

\subsubsection{SocketIO Logik}
Der nun funktionierende Web-Server soll nun SocketIO-Verbindungen, die vom Browser kommen, annehmen können.
Mit der SocketIO Instanz, die im letzten Abschnitt erstellt worden ist, kann dieses Problem sehr leicht gelöst werden:

\begin{lstlisting}[caption=,language=Java,label=lst:impl:socketIO]
    io.sockets.on('connection', newConnection);

    function newConnection(socket) {
        // LOGIC COMES HERE
    }
\end{lstlisting}

Findet nun eine Verbindung zu dem Server von einem Client statt, wird die Methode <newConnection(socket)> aufgerufen.
Der Parameter der Methode ist eine Socket-Instanz, die sehr viele Informationen und Funktionalitäten der gerade bestehenden Verbindung enthält.
Wie der Client eine Verbindung zu diesem Server aufbauen kann, ist von Programmiersprache zu Programmiersprache unterschiedlich. Im Frontend von ScribbleFight wird JavaScritp benutzt.

\textbf{SocketIO im Frontend}

Um im Frontend eine SocketIO-Verbindung aufzubauen, wird zuerst in dem index.html File die SocketIO Library verlinkt:
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // link SocketIO in index.html
    <script src="https://cdn.socket.io/4.1.2/socket.io.min.js"></script>
\end{lstlisting}

Jetzt kann einfach eine neue Socket-Instanz erstellt werden mit der der Client Events empfangen, aber auch aussenden kann.
Da der Server von ScribbleFight nicht mehr lokal läuft, sondern auf einem Kubernetes-Cluster, wird hierbei noch ein Pfad definiert, um eine korrekte Instanz zu erstellen.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    var socket = io({
        path: "/t.rafetseder/scribble-fight/socket.io"
      }); 
\end{lstlisting}

Einfach nur der Befehl \texttt{io()} würde die Pfad-Parameter (/t.rafetseder/scribble-fight/socket.io) der derzeiten Domaine einfach ignorieren und die Verbindung könnte nicht hergestellt werden.
\\
Nun können mit dem Befehl
\texttt{socket.on('event',funciton)} Events empfangen, und mit \texttt{socket.emit('event')} Events ausgelöst werden.

\textbf{SocketIO Events} \\
Nachdem nun eine aufrechte Verbindunge hergestellt werden konnte, gibt es 10 Events, die passieren können.
\begin{compactitem}
    \item Ein neuer Spieler soll erstellt werden
    \item Abruf von schon bestehenden Spielern
    \item Die Position von meinem Sprite soll aktualisiert werden
    \item Die Richtung, in die mein Sprite schaut, soll aktualisiert werden
    \item Ein Item wurde aufgehoben, also soll es bei jedem entfernt werden
    \item Jemand hat eine Attacke ausgeführt, also soll bei jedem ein Projektil erstellt werden
    \item Jemand hat einen Kill erzielt
    \item Ein Spieler wurde von einem Projektil getroffen, das heißt das Projektil, das getroffen hat, muss bei jedem entfernt werden
    \item Jemand ist gestorben
    \item Es soll ein neues Item erstellt werden (Passiert alle 10 Sekunden)
\end{compactitem}

Diese Events werden im Folgenden genau erklärt.

\textbf{Erstellen eines neuen Spielers und Abrufen von vorhandenen Spieler} \\
Führt der Spieler das Frontend aus, stellt dieses sofort eine Verbindung mit dem Sever her. Um nun schon vorhandene Spieler, die gerade auch verbunden sind zu erhalten, wird ein Event <getPlayers> emittiert.
Danach muss dem Server noch mitgeteilt werden, dass der Spieler nun selbst auch eine spielbare Figur erhlaten möchte. Dies wird mit dem <newPlayer>-Event bewerkstelligt.
Wird nun das Event <newPlayer> vom Server ausgelöst, wird ein neues Player-Objekt dem Player-Array des Frontends hinzugefügt. Der Konstruktur von diesem Player-Objekt benötigt nur einen Sprite, der auch neu erstellt wird.
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // listen to an event from the server
    socket.on('newPlayer',createNewPlayer);
    // get existing players
    socket.emit('getPlayers');
    // create my own player
    socket.emit('newPlayer');

    function createNewPlayer(data) {
        // new player gets added an new sprite is created in the middle of the map
        players[data.id] = new Player(createSprite(ImageWidth / 2,ImageHeight / 2, player_width, player_height));
    }
\end{lstlisting}

Im Server sieht das Ganze etwas komplizierter aus. Grundsätzlich speichert der Server alle Player-Objekte in einem Map-Objekt ab.
Die ID für jedes dieser Player-Objekte dient einfach die ID der Socket-Verbindung. Will ein Client nun alle schon vorhandenen Spieler, wird die Map (falls Spieler vorhanden) durchlaufen, und die ID von jedem der Spieler an den anfragenden Client geschickt.
Dieser erstellt dann einen neuen Player / mehrere neue Player mit der dazugehörigen ID.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('getPlayers',sendPlayers);

    // the object players is the map that has the player-objects saved
    function sendPlayers() {
        if (players.size > 0) {
            players.forEach((values, keys) => {
                let data = {
                    id: values.id,
                }
                socket.emit('newPlayer', data);
            })
        }
    }
\end{lstlisting}

Nachdem nun der Server alle schon vorhanden Spieler dem Client mitgeteilt hat, muss noch ein neuer Spieler für diesen Client erstellt werden.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('newPlayer',createPlayer);  

    function createPlayer() {
        players.set(socket.id, new Player(socket.id));
        let data = {
            id: socket.id,
        }
        // im using io.emit() so it sends to everyone, including the client that triggered the event
        io.emit('newPlayer', data);
    }
\end{lstlisting}

Der Client erstellt nun genau gleich wie bei dem <getPlayers>-Event den Spieler.

\textbf{Update Position and Update Direction}

Die Postion des Sprites von jedem Spieler soll in jedem Draw-Zyklus geupdatet werden. Die Orientierung des Sprites soll nur dann aktualisiert werden, wenn der Spieler die Richtung seines Sprites wechselt. (Beschrieben in Kapitel \ref{directionChange})
Leider ergibt sich beim Aktualisieren von Positionen von Sprites ein Problem. Die Koordinaten in p5.js weden in Pixel angeben. Das bedeuet, haben unterschiedliche Client unterschiedlich große Endgeräte, befinden sich Sprites mit gleichen Koordinaten an unterschiedlichen Stellen.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/pixelDiff.PNG}
    \caption{Pixel-Unterschied}
\end{figure}

Aus diesem Grund können nicht einfach nur die rohen Koordinaten an alle Clients geschickt werden, sie müssen in Relation zu dem Bildschirm des Endgeräts und der Größe der Map, also dem Bild auf dem gerade gespielt wird, gesetzt werden.
(Dies ist nicht nur bei den Spieler-Koordintaten, sondern auch bei z.B. Items der Fall)
Der Code am Ende von jedem Draw-Zyklus sieht also so aus:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    let transferX = (myPlayer.sprite.position.x - (windowWidth - ImageWidth) / 2) * originalBildBreite / neueBildBreite;
    let transferY = (myPlayer.sprite.position.y - (windowHeight - ImageHeight) / 2) * originalBildHoehe / neueBildHoehe;
    relPosData = {
      x: transferX,
      y: transferY
    }
    socket.emit('update', relPosData);
\end{lstlisting}

Im Server werden diese Koordinaten einfach zusammen mit der passenden ID des Players an alle Spieler verteilt:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

socket.on('update',updatePosition)

    function updatePosition(data) {
        let posData = {
            x: data.x,
            y: data.y,
            id: socket.id
        }
        // with socket.broadcast, everyone except the one who triggered the event gets the data
        socket.broadcast.emit('updatePosition', posData);
    }
\end{lstlisting}

Empfängt ein Client die Koordinaten, muss er diese dann wieder für sein Endgerät richtig umwandeln:


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

socket.on('updatePosition',updatePosition);

    function updatePosition(data) {
        players[data.id].sprite.position.x = 
        data.x * neueBildBreite / originalBildBreite + (windowWidth - neueBildBreite) / 2;

        players[data.id].sprite.position.y = 
        data.y * neueBildHoehe / originalBildHoehe + (windowHeight - neueBildHoehe) / 2;
    }
\end{lstlisting}

Das Aktualisieren der Richtung des Sprites ist hingegen leichter. Dort spielt es keine Rolle, wie groß das Endgerät ist.
Beim Drücken von A oder D auf der Tastatur, wird einfach ein Event ausgelöst, dass die Richtung des Sprites bei jedem verbundenen Spieler ändert.


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    // A
    if (keyWentDown(65)) {
        socket.emit('updateDirection', 'left');
    }
    // D
    if (keyWentDown(68)) {
        socket.emit('updateDirection', 'right');
    }
\end{lstlisting}

Im Server wird die Information nun einfach an alle Clients verteilt:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
   socket.on('updateDirection',updateDirection);

   function updateDirection(data) {
    let dataWithId = {
        id: socket.id,
        direction: ""
    }
        if (data == "left") {
            dataWithId.direction = "left";
            socket.broadcast.emit('updateDirection', dataWithId);
        } else if (data == "right") {
            dataWithId.direction = "right";
            socket.broadcast.emit('updateDirection', dataWithId);
        }
}
\end{lstlisting}

Wird vom Client nun das <updateDirection>-Event empfangen, wird einfach die Orientierung des Sprites geändert.

\textbf{Synchronisieren von Projektilen oder Items} \\
Wenn ein Item aufgesammelt wird, soll dieses natürlich für die anderen Spieler nicht mehr verfügbar sein. Genauso soll, wenn eine Attacke ausgeführt wird, diese bei allen anderen Spielern auch ausgeführt werden.
Die Logik dazu ist relativ simpel. Jedes Item bekommt beim Erstellen eine eigene unique ID. Sammelt nun irgendein Spieler dieses Item auf, wird an den Server eine Benachrichtigung gesendet, dass jemand dieses Item aufgesammelt hat.
Dieser verteilt diese Information einfach an alle Spieler, und das Item mit der richtigen ID wird bei jedem gelöscht.
Bei den Projektilen ist es ähnlich. Wenn ein Spieler eine Attacke ausführt, wird auch das dem Server mitgeteilt. Der verteilt nun wieder die Information an alle Spieler, und bei jedem wird ein neues Projekil mit der gleichen ID erstellt.
Wenn irgendeiner der Spieler eine Kollision zwischen Player-Sprite und einem Projekil feststellt, wird das dem Server mitgeilt und dieser teilt wieder allen anderen Spielern mit, dass das Projektil bei jedem gelöscht werden muss.
Der Server hat einen Array mit Item-Objekten gespeichert. Vereinfacht sieht die Logik so auf der Server-Seite aus:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]

    socket.on('deleteItem', deleteItem);
    socket.on('attack', syncAttacks);
    socket.on('deleteAttack', deleteAttack);

    function deleteItem(data) {
        items.forEach(i => {
            if (i == data.id) {
                // remove item from item array
                items.splice(items.indexOf(i), 1);
                socket.broadcast.emit('deleteItem', data);
            }
        });
    }

    // data consist of type of attack and attack ID
    function syncAttacks(data) {
        socket.broadcast.emit('attack', data);
    }

    // data consist of type of attack and attack ID
    function deleteAttack(data) {
        socket.broadcast.emit("deleteAttack", data);
    }

 \end{lstlisting}

Im Frontend werden einfach die bestimmten Events am richtigen Ort ausgelöst.
Zum Beispiel, wenn eine Bombe erstellt wird:

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    funciton addBomb() {
        // bomb gets created here
        let data = {
            playerId: socket.id,
            type: "bomb",
            x: bomb.position.x,
            y: bomb.position.y,
        }   
        socket.emit("attack",data);
    }
 \end{lstlisting}


Natürlich befindet sich auch die Logik, um die vom Server ausgelösten Events zu empfangen und darauf zu reagieren, am Client.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('deleteItem', syncItems);
    socket.on('attack', addAttack);
    socket.on('deleteAttack', deleteAttack);

    // remove item from the item array
    function syncItems(data) {
        items[data.index].remove();
        items.splice(items.indexOf(items[data.index]), 1);
    }

    // add a projectile, depending on the type of attack
    function addAttack(data) {
    switch (data.type) {
        case "default": addDefaultAttack(data);
            break;
        case "bomb": addBomb(data);
            break;
        case "blackHole": addBlackHole(data);
            break;
        case "piano": addPiano(data);
            break;
        case "mine": addMine(data);
            break;
        case "small": addSmall(data);
            break;
        }  
    }

    // delete the right projectile, depending on the type and the ID of the projectile
    function deleteAttack(data) {
        
        switch (data.type) {
            case "default":
                projectiles.forEach(p => {
                    if (p.id === data.id) {
                        p.remove();
                    }
                });
                break;
            case "bomb":
                bombs.forEach(b => {
                    if (b.id === data.id) {
                        b.remove();
                    }
                });
                break;
        // ... and so on
        }
    }

 \end{lstlisting}

Somit ist schon die meiste Logik des Servers gegeben. Was aber noch wichtiges fehlt, ist, dass wenn jemand aus der Spielumgebung fällt, immer auf Gewinner überprüft und Kills abgespeichert werden müssen.

\textbf{Tode und Kills} \\
Wie der Spieler in ScribbleFight gewinnt, wann er 'stirbt' und wie er Kills sammelt wird alles auf der Client-Seite in Kapitel \ref{impl:win} beschrieben.
Doch natürlich muss der Client auch mit dem Server kommunizieren, damit dieser alle diese Events auch an alle anderen Spieler mitteilen kann.
Stirbt ein Spieler, teilt er dies dem Server mit. Dieser speichert die Information ab und überprüft, ob der Spieler noch weiter mitspielen darf.
Ist er jedoch schon zum dritten Mal gestorben, ist dies nicht mehr der Fall und der Spieler wird aus der Spieler-Map vom Server gelöscht.
Ist ab dem Zeitpunkt nur mehr ein einziger Spieler in dem Map-Objekt gespeichert, hat dieser gewonnen.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    function death(data) {
        players.get(data.deadPlayer).death++;
        if (players.get(data.deadPlayer).death >= 3) {
            // delete the player from player-map
            players.delete(data.deadPlayer);
            let transferData = {
                id: data.deadPlayer
            }
            // send the information that someone died to everyone
            io.emit('death', transferData);
            // disconnect the socket connection
            socket.disconnect();
        }
        // if player-map only has one player left, he has won 
        if (players.size <= 1) {
            socket.broadcast.emit("win");
        }
    }
 \end{lstlisting}

Der Client muss natürlich jetzt auf beide Events, also falls er gerade vom Spiel ausgeschieden wurde, oder gerade gewonnen hat, reagieren können.
Bekommt er die Benachrichtigung, dass gerade jemand ausgeschieden wurde, wird überprüft, ob es sich um ihn selbst handelt.
Falls ja, wird die draw-Methode gestoppt, ihm wird mitgeilt, dass er verloren hat und eine kurze Übersicht von seinen Spiel-Statistiken wird angezeigt.
Die Übersicht beinhaltet:
\begin{compactitem}
    \item Den Schaden, den er an alle anderen Spieler ausgeteilt hat
    \item Anzahl an Kills, die erzielt worden sind
    \item Der eigene Knockback, also ein Indikator wie oft der Spieler getroffen worden ist
\end{compactitem}
Falls es sich nicht um ihn handelt, passiert nichts.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('death',someoneDied);

    // data consits of id of dead player
    function someoneDied(data) {
    players[data.id].sprite.remove();
    if (data.id == myPlayer.id) {
        alert("You died!\n
        Your kills: " + myPlayer.kills + "\n" 
        + "Your damage: " + myPlayer.dmgDealt + "\n" 
        + "Your knockback: " + myPlayer.knockback);

        // stop the draw-function
        noLoop();
    }
}
 \end{lstlisting}

Bekommt der Spieler nun aber die Benachrichtigung, dass er gewonnen hat, wird diese Nachrichte ausgegeben und auch hier wird wieder eine kurze Übersicht der Spiel-Statistiken gezeigt.
Diesmal aber inklusive den Toden, da sie dieses Mal nicht mit Sicherheit drei sind.

\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('win',win);
     
    function win() {
        alert("You won!\n
        Your kills: " + myPlayer.kills + "\n" 
        + "Your damage: " + myPlayer.dmgDealt 
        + "\n" + "Your knockback: " + myPlayer.knockback 
        + "\n" + "Your deaths: " + myPlayer.death);
    }
 \end{lstlisting}

Wird im Client bestimmt, dass gerade ein Kill erzielt worden ist, speichert der Sever diese Information ab, damit sie immer abrufbar ist.
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('kill',kill);
    
    // data consists of the id of the player who should get the kill
    function kill(data) {
        // player could leave before getting the kill
        if (players.get(data.damagedBy) != undefined) {
            players.get(data.damagedBy).kill += 1;
    }

 \end{lstlisting}

Nun hat der Server schon fast die ganze Funktionalität, die er benötigt, damit das Web-Game funktionert.
Das Einzige, was fehlt, ist dass der Server allen Spielern immer mitteilen muss, wann ein neues Item erscheinen soll.

\textbf{Item-Spawn-Event} \label{impl:itemSpawnB} \\
Items werden in ScribbleFight alle 10 Sekunden gespawned, falls ein Spieler mit dem Server verbunden ist.
Auf der Server-Seite ist das leicht umzusetzen. Mit der Methode \texttt{setIntervall()} kann einfach ein Intervall definiert werden, in dem eine Funktion ausgeführt werden soll.
Das Intervall wird auf 10 Sekunden gesetzt. Nun wird, solange ein Spieler vorhanden ist, alle 10 Sekunde ein Event ausgelöst, dass allen verbundenen Spielern mitteilt, wo, welche Art von Item erstellt werden soll.
Wie die x-Koodinaten berechnet werden, die für die Item-Spawns in Frage kommen, wird in Kapitel \ref{impl:xCoordinates} beschrieben.
Auf der Server-Seite sieht der Code also so aus:
\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    setInterval(() => {
        // if players are connected with the server
        if (players.size > 0) {
            // get one of the available spawn points for items
            let x = getItemSpawnPoint();
            let data = {
                id: randomId(),
                x: x,
                num: getRandomInt(5)
            }
            // too many items on the field
            if (x != -1) {
                items.push(data.id);
            }
            // sending the event to every connected player
            io.emit('spawnItem', data);
        }
    }, 10000);

 \end{lstlisting}

Der Client muss jetzt nur mehr beim Empfangen dieses Events ein Item am richtigen Ort erstellen.
Wie Items am Client erstellt werden, kann in Kapitel \ref{impl:itemSpawnF} nachgelesen werden.\\
Vereinfacht sieht der Code am Client also so aus:


\begin{lstlisting}[,language=Java,label=lst:impl:socketIO]
    socket.on('spawnItem',createItem);

    // data consits of item-ID, type of item and position of item
    funciton createItem(data) {
        // item gets created here
    }
 \end{lstlisting}

Das waren allen Funktionalitäten des ScribbleFight-Web-Servers. Dieser läuft allerdings nicht mehr lokal, sondern auf einem Kubernetes-Cluster: Der Leocloud.
Wie der Server deployed werden konnte, wird in dem nächsten Kapitel beschrieben.


\section{Deployment [R]} \label{impl:Deployment}
\setauthor{Rafetseder Tobias}
Die Grundlage, um etwas auf einen Kubernetes-Cluster deployen zu können, ist ein Docker-Image. Näheres zu der Docker-Technologie wird in Kapitel \ref{tech:docker} beschrieben.
\subsection{Docker-Image [R]}
Da es sich bei dem Server, der für das Web-Spiel notwendig ist, nur um einen Web-Server, der statische Files hostet, handelt, und keine Datenbank nötig ist, ist das Docker-File relativ simpel.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.85]{pics/dockerfile_scribble.PNG}
    \caption{ScribbleFight Dockerfile}
\end{figure}
Die Zeilen Code werden im Folgenden genauer erläutert. \\
\begin{lstlisting}
    FROM node:16
\end{lstlisting}
Da Docker-Images von anderen Docker-Images erben können, wird nicht ein eigenes Base-Images verwendet, sondern das offizielle Node.js Image, das schon die Tools und Packages hat, die benötigt werden, um eine Node.js-Applikation auszuführen.
\\
\begin{lstlisting}
    WORKDIR /usr/src/app
\end{lstlisting}
Es wird ein neues Verzeichnis erstellt, von wo aus gearbeitet wird.
In diesem Verzeichnis werden alle folgenden Befehle ausgeführt. Der Vorteil davon ist, dass keine absoluten File-Paths benutzt werden müssen, sondern relativ zu diesem Verzeichnis relativ-Paths benutzt werden können. \\


\begin{lstlisting}
    COPY ./p5_backend/package*.json ./p5_backend/
\end{lstlisting}
Bevor \texttt{npm install} ausgeführt werden kann, muss das package.json File und package-lock.json File auf das Image kopiert werden.
Um das machen zu können, wird \texttt{COPY} benutzt. Dieser Befehl nimmt zwei Parameter: Source und Destination. Es werden package.json und package-lock.json in einen neuen Ordner des vorherig erstellen Arbeits-Verzeichnis kopiert. \\

\begin{lstlisting}
    WORKDIR /usr/src/app/p5_backend
    RUN npm install
\end{lstlisting}
Es wird nun das Verzeichnis, in das das package.json-und package-lock.json File kopiert worden sind, als Arbeits-Verzeichnis definiert.
Da dort diese Files vorhanden sind, kann \texttt{npm install} ausgeführt werden und alle nötigen Dependencies werden heruntegeladen. \\

\begin{lstlisting}
    WORKDIR /usr/src/app
    COPY ./p5_backend ./p5_backend
    COPY ./p5_frontend ./p5_frontend
\end{lstlisting}

Nun wird wieder das ursprüngliche Verzeichnis als Arbeits-Verzeichnis definiert. Dorthin werden die Files, die der Server zum Funktionieren braucht und auch die Files für das Frontend, die der Server hostet, kopiert. \\

\begin{lstlisting}
    EXPOSE 3000
    CMD [ "node", "./p5_backend/server.js" ]
\end{lstlisting}

Zuletzt wird nur mehr der Port, den der ScribbleFight-Server akzeptiert, nach aussen freigegeben, und mit dem Befehl \texttt{CMD} der Server gestartet. \cite{build_image}

\subsection{Leo-Cloud [R]}
Die Leo-Cloud ist eine Cloud-Computing-Umgebung der HTL Leonding.
Da nun ein funktionierendes Image des Web-Servers vorhanden ist, kann an dem Deployment an die Leo-Cloud gearbeitet werden.

Zuerst muss das Image, das für das Deployment verwendet werden soll, in das Docker-Registry der HTL Leonding geladen werden.
Dazu kann der Befehl \texttt{docker login registry.cloud.htl-leonding.ac.at} benutzt werden, um sich mit den eigenen Anmeldedaten dort einzuloggen.
Danach wird das Image einfach mit dem Befehl \texttt{docker push registry.cloud.htl-leonding.ac.at/t.rafetseder/<image-name>/<image-version>} hochgeladen.

Um das Deployment umzusetzten, werden drei YAML-Files benötigt.
YAML ist eine Daten-Serialisierungs-Sprache, die gerne benutzt wird, um Konfigurations-Files zu schreiben.

Diese drei Files sind:
\begin{compactitem}
    \item Deployment-File
    \item Service-File
    \item Ingress-File
\end{compactitem}

In dem Deployment-File kann die Konfigurationen zum eigentlichen Deployment festgelegt werden, zum Beispiel welches Image verwendet werden soll,
welche Anzahl an Pods (Linux-Containern) verwendet werden sollen, oder welcher Port benutzt werden soll.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.85]{pics/deployment.PNG}
    \caption{ScribbleFight Deployment.yaml}
\end{figure}

Auf einem Kubernetes-Cluster laufen viele Pods. Diese müssen in einer Weise verbindet werden. Das ist der Job von Service-Files.
Service abstrahiert die IP-Adresse eines Pods zu einem statischen Service-Name, sodass externe Requests zu multiplen Pods geleitet werden können.
\\
Das Weiterleiten von Requests zu dem erwünschten Pod basiert auf der \texttt{selector}-spec am Service, der mit dem Metadaten-Label des Pods zusammenpassen muss.

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{pics/service.PNG}
    \caption{ScribbleFight Service.yaml}
\end{figure}

Zusätzlich muss noch konfiguriert werden, wie Services in einem Cluster via IP-Adresse oder URL erreicht werden können.
Dazu werden Ingress-Files verwendet. Ein Ingress ist eine Ansammlung von Regeln, die einkommende Verbindungen erlauben, Cluster-Servives zu erreichen.
Das Ingress-Spec-Field stellt einen Service-Namen und Service-Port bereit, der gemeinsam mit der URL-Route von dem Service exposed wird.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.85]{pics/ingress.PNG}
    \caption{ScribbleFight Ingress.yaml}
\end{figure}



% Ben dein teil kommt hier herein

\input{./sections/Jonas/mapandai.tex}


% Siehe tolle Daten in Tab. \ref{tab:impl:data}.

% \begin{table}
%     \centering
%     \begin{tabular}{|lcc|}
%         \hline
%                   & \textbf{Regular Customers} & \textbf{Random Customers} \\ \hline
%         Age       & 20-40                      & \textgreater{}60          \\ \hline
%         Education & university                 & high school               \\ \hline
%     \end{tabular}
%     \caption{Ein paar tabellarische Daten}
%     \label{tab:impl:data}
% \end{table}

% \begin{figure}
%     \centering
%     \includegraphics[scale=0.5]{pics/knuthi.jpg}
%     \caption{Don Knuth -- CS Allfather}
%     \label{fig:impl:knuth}
% \end{figure}

% Siehe und staune in Abb. \ref{fig:impl:knuth}.
% \lipsum[6-9]
% Dann betrachte den Code in Listing \ref{lst:impl:foo}.

% \begin{lstlisting}[language=Python,caption=Some code,label=lst:impl:foo]
% # Program to find the sum of all numbers stored in a list (the not-Pythonic-way)

% # List of numbers
% numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]

% # variable to store the sum
% sum = 0

% # iterate over the list
% for val in numbers:
%     sum = sum+val

% print("The sum is", sum)
% \end{lstlisting}